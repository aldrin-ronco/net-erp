schema {
  mutation: RootMutationType
  query: RootQueryType
}

type RootQueryType {
  "List all repositories with filters and pagination"
  repositories(
    "Search filters"
    filter: RepoFilters

    "Pagination options"
    pagination: Pagination
  ): RepoConnection

  "Get a specific repository by name"
  repository(
    "Repository name"
    name: String!
  ): Repository

  "Get general repository statistics"
  repositoryStats: RepoStats

  "Check if a repository exists"
  repositoryExists(
    "Repository name to check"
    name: String!
  ): Boolean!

  "Get paginated list of countries"
  countriesPage(
    pagination: Pagination

    filters: CountryFilters

    "Sort configuration"
    sort: [CountrySortInput]
  ): CountryPage

  "Get country by ID"
  country(
    "Country ID to fetch"
    id: ID!
  ): Country

  "Get country by code"
  countryByCode(
    "Country code to fetch"
    code: String!
  ): Country

  "Check if a country can be deleted"
  canDeleteCountry(
    "Country ID to check"
    id: ID!
  ): CanDeleteCountryPayload

  "Get a paginated audit timeline for a Country"
  countryTimelinePage(
    "Country ID"
    id: ID!

    pagination: Pagination

    filters: CountryTimelineFilters

    "Sort configuration"
    sort: [CountryTimelineSortInput]
  ): CountryTimelinePage

  "Reconstruct Country at a specific audit version"
  countryAtVersion(id: ID!, versionId: ID!): Country

  "Reconstruct Country as of a timestamp"
  countryAsOf(id: ID!, at: IsoDatetime!): Country

  "Get paginated list of departments"
  departmentsPage(
    pagination: Pagination

    filters: DepartmentFilters

    "Sort configuration"
    sort: [DepartmentSortInput]
  ): DepartmentPage

  "Get department by ID"
  department(
    "Department ID to fetch"
    id: ID!
  ): Department

  "Get department by code and country"
  departmentByCodeAndCountry(
    "Department code"
    code: String!

    "Country ID"
    countryId: ID!
  ): Department

  "Get department by country_code and department_code"
  departmentByCodes(
    "ISO numeric country code (e.g. '170')"
    countryCode: String!

    "Department code (e.g. '05')"
    departmentCode: String!
  ): Department

  "Check if a department can be deleted"
  canDeleteDepartment(
    "Department ID to check"
    id: ID!
  ): CanDeleteDepartmentPayload

  "Get a paginated audit timeline for a Department"
  departmentTimelinePage(
    "Department ID"
    id: ID!

    pagination: Pagination

    filters: DepartmentTimelineFilters

    "Sort configuration"
    sort: [DepartmentTimelineSortInput]
  ): DepartmentTimelinePage

  "Reconstruct Department at a specific audit version"
  departmentAtVersion(id: ID!, versionId: ID!): Department

  "Reconstruct Department as of a timestamp"
  departmentAsOf(id: ID!, at: IsoDatetime!): Department

  "Get paginated list of cities"
  citiesPage(
    pagination: Pagination

    filters: CityFilters

    "Sort configuration"
    sort: [CitySortInput]
  ): CityPage

  "Get city by ID"
  city(
    "City ID to fetch"
    id: ID!
  ): City

  "Get city by code and department"
  cityByCodeAndDepartment(
    "City code"
    code: String!

    "Department ID"
    departmentId: ID!
  ): City

  "Get city by country_code, department_code and city_code"
  cityByCodes(
    "ISO numeric country code (e.g. '170')"
    countryCode: String!

    "Department code (e.g. '05')"
    departmentCode: String!

    "City code (e.g. '001')"
    cityCode: String!
  ): City

  "Check if a city can be deleted"
  canDeleteCity(
    "City ID to check"
    id: ID!
  ): CanDeleteCityPayload

  "Get a paginated audit timeline for a City"
  cityTimelinePage(
    "City ID"
    id: ID!

    pagination: Pagination

    filters: CityTimelineFilters

    "Sort configuration"
    sort: [CityTimelineSortInput]
  ): CityTimelinePage

  "Reconstruct City at a specific audit version"
  cityAtVersion(id: ID!, versionId: ID!): City

  "Reconstruct City as of a timestamp"
  cityAsOf(id: ID!, at: IsoDatetime!): City

  "Get paginated list of companies"
  companiesPage(
    pagination: Pagination

    filters: CompanyFilters

    "Sort configuration"
    sort: [CompanySortInput]
  ): CompanyPage

  "Get company by ID"
  company(
    "Company ID to fetch"
    id: ID!
  ): Company

  "Get company with its accounting entity preloaded"
  companyWithEntity(
    "Company ID to fetch with entity"
    id: ID!
  ): Company

  "Check if a company can be deleted"
  canDeleteCompany(
    "Company ID to check"
    id: ID!
  ): CanDeleteCompanyPayload

  "Get paginated list of company locations"
  companyLocationsPage(
    pagination: Pagination

    filters: CompanyLocationFilters

    "Sort configuration"
    sort: [CompanyLocationSortInput]
  ): CompanyLocationPage

  "Get company location by ID"
  companyLocation(
    "Company location ID to fetch"
    id: ID!
  ): CompanyLocation

  "Get company location by name"
  companyLocationByName(
    "Company location name to fetch"
    name: String!
  ): CompanyLocation

  "Check if a company location can be deleted"
  canDeleteCompanyLocation(
    "Company location ID to check"
    id: ID!
  ): CanDeleteCompanyLocationPayload

  "Get a paginated audit timeline for a CompanyLocation"
  companyLocationTimelinePage(
    "CompanyLocation ID"
    id: ID!

    pagination: Pagination

    filters: CompanyLocationTimelineFilters

    "Sort configuration"
    sort: [CompanyLocationTimelineSortInput]
  ): CompanyLocationTimelinePage

  "Reconstruct CompanyLocation at a specific audit version"
  companyLocationAtVersion(id: ID!, versionId: ID!): CompanyLocation

  "Reconstruct CompanyLocation as of a timestamp"
  companyLocationAsOf(id: ID!, at: IsoDatetime!): CompanyLocation

  "Get paginated list of storages"
  storagesPage(
    pagination: Pagination

    filters: StorageFilters

    "Sort configuration"
    sort: [StorageSortInput]
  ): StoragePage

  "Get storage by ID"
  storage(
    "Storage ID to fetch"
    id: ID!
  ): Storage

  "Get storage by name"
  storageByName(
    "Storage name to fetch"
    name: String!
  ): Storage

  "Check if a storage can be deleted"
  canDeleteStorage(
    "Storage ID to check"
    id: ID!
  ): CanDeleteStoragePayload

  "Get paginated audit timeline for a storage with filters and sort"
  storageTimelinePage(
    "Storage ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: StorageTimelineFilters

    sort: [StorageTimelineSortInput]
  ): StorageTimelinePage

  "Get the state of a storage reconstructed at a specific version id"
  storageAtVersion(
    "Storage ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Storage

  "Get the state of a storage reconstructed as of the given timestamp (inclusive)"
  storageAsOf(
    "Storage ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Storage

  "Get paginated list of cost centers"
  costCentersPage(
    pagination: Pagination

    filters: CostCenterFilters

    "Sort configuration"
    sort: [CostCenterSortInput]
  ): CostCenterPage

  "Get cost center by ID"
  costCenter(
    "Cost center ID to fetch"
    id: ID!
  ): CostCenter

  "Get cost center by name"
  costCenterByName(
    "Cost center name to fetch"
    name: String!
  ): CostCenter

  "Get cost center by short name"
  costCenterByShortName(
    "Cost center short name to fetch"
    shortName: String!
  ): CostCenter

  "Check if a cost center can be deleted"
  canDeleteCostCenter(
    "Cost center ID to check"
    id: ID!
  ): CanDeleteCostCenterPayload

  "Audit timeline for a Cost Center"
  costCenterTimelinePage(
    "Cost Center ID"
    id: ID!

    pagination: Pagination

    filters: CostCenterTimelineFilters

    sort: [CostCenterTimelineSortInput]
  ): CostCenterTimelinePage

  "Reconstruct Cost Center at a specific version"
  costCenterAtVersion(
    "Cost Center ID"
    id: ID!

    "Version ID"
    versionId: ID!
  ): CostCenter

  "Reconstruct Cost Center as of a timestamp"
  costCenterAsOf(
    "Cost Center ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): CostCenter

  "Get paginated list of modules"
  modulesPage(
    pagination: Pagination

    filters: ModuleFilters

    "Sort configuration"
    sort: [ModuleSortInput]
  ): ModulePage

  "Get module by ID"
  module(
    "Module ID to fetch"
    id: ID!
  ): Module

  "Get module by code"
  moduleByCode(
    "Module code to fetch"
    code: String!
  ): Module

  "Check if a module can be deleted"
  canDeleteModule(
    "Module ID to check"
    id: ID!
  ): CanDeleteModulePayload

  "Audit timeline for a Module"
  moduleTimelinePage(
    "Module ID"
    id: ID!

    pagination: Pagination

    filters: ModuleTimelineFilters

    sort: [ModuleTimelineSortInput]
  ): ModuleTimelinePage

  "Reconstruct Module at a specific version"
  moduleAtVersion(
    "Module ID"
    id: ID!

    "Version ID"
    versionId: ID!
  ): Module

  "Reconstruct Module as of a timestamp"
  moduleAsOf(
    "Module ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Module

  "Get paginated list of process types"
  processTypesPage(
    pagination: Pagination

    filters: ProcessTypeFilters

    "Sort configuration"
    sort: [ProcessTypeSortInput]
  ): ProcessTypePage

  "Get process type by ID"
  processType(
    "Process type ID to fetch"
    id: ID!
  ): ProcessType

  "Check if a process type can be deleted"
  canDeleteProcessType(
    "Process type ID to check"
    id: ID!
  ): CanDeleteProcessTypePayload

  "Audit timeline for a ProcessType"
  processTypeTimelinePage(
    "ProcessType ID"
    id: ID!

    pagination: Pagination

    filters: ProcessTypeTimelineFilters

    sort: [ProcessTypeTimelineSortInput]
  ): ProcessTypeTimelinePage

  "Reconstruct ProcessType at a specific version"
  processTypeAtVersion(
    "ProcessType ID"
    id: ID!

    "Version ID"
    versionId: ID!
  ): ProcessType

  "Reconstruct ProcessType as of a timestamp"
  processTypeAsOf(
    "ProcessType ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): ProcessType

  "Get paginated list of identification types"
  identificationTypesPage(
    pagination: Pagination

    filters: IdentificationTypeFilters

    "Sort configuration"
    sort: [IdentificationTypeSortInput]
  ): IdentificationTypePage

  "Get identification type by ID"
  identificationType(
    "Identification type ID to fetch"
    id: ID!
  ): IdentificationType

  "Get identification type by code"
  identificationTypeByCode(
    "Identification type code to fetch"
    code: String!
  ): IdentificationType

  "Check if an identification type can be deleted"
  canDeleteIdentificationType(
    "Identification type ID to check"
    id: ID!
  ): CanDeleteIdentificationTypePayload

  "Get paginated audit timeline for an identification type with filters and sort"
  identificationTypeTimelinePage(
    "Identification type ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: IdentificationTypeTimelineFilters

    sort: [IdentificationTypeTimelineSortInput]
  ): IdentificationTypeTimelinePage

  "Get the state of an identification type reconstructed at a specific version id"
  identificationTypeAtVersion(
    "Identification type ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): IdentificationType

  "Get the state of an identification type reconstructed as of the given timestamp (inclusive)"
  identificationTypeAsOf(
    "Identification type ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): IdentificationType

  "Get paginated list of accounting accounts"
  accountingAccountsPage(
    pagination: Pagination

    filters: AccountingAccountFilters

    "Sort configuration"
    sort: [AccountingAccountSortInput]
  ): AccountingAccountPage

  "Get accounting account by ID"
  accountingAccount(
    "Accounting account ID to fetch"
    id: ID!
  ): AccountingAccount

  "Get accounting account by code"
  accountingAccountByCode(
    "Accounting account code to fetch"
    code: String!
  ): AccountingAccount

  "Check if an accounting account can be deleted"
  canDeleteAccountingAccount(
    "Accounting account ID to check"
    id: ID!
  ): CanDeleteAccountingAccountPayload

  "Get paginated audit timeline for an accounting account with filters and sort"
  accountingAccountTimelinePage(
    "Accounting account ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingAccountTimelineFilters

    sort: [AccountingAccountTimelineSortInput]
  ): AccountingAccountTimelinePage

  "Get the state of an accounting account reconstructed at a specific version id"
  accountingAccountAtVersion(
    "Accounting account ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingAccount

  "Get the state of an accounting account reconstructed as of the given timestamp (inclusive)"
  accountingAccountAsOf(
    "Accounting account ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingAccount

  "Get paginated list of accounting books"
  accountingBooksPage(
    pagination: Pagination

    filters: AccountingBookFilters

    "Sort configuration"
    sort: [AccountingBookSortInput]
  ): AccountingBookPage

  "Get accounting book by ID"
  accountingBook(
    "Accounting book ID to fetch"
    id: ID!
  ): AccountingBook

  "Check if an accounting book can be deleted"
  canDeleteAccountingBook(
    "Accounting book ID to check"
    id: ID!
  ): CanDeleteAccountingBookPayload

  "Get paginated audit timeline for an accounting book with filters and sort"
  accountingBookTimelinePage(
    "Accounting book ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingBookTimelineFilters

    sort: [AccountingBookTimelineSortInput]
  ): AccountingBookTimelinePage

  "Get the state of an accounting book reconstructed at a specific version id"
  accountingBookAtVersion(
    "Accounting book ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingBook

  "Get the state of an accounting book reconstructed as of the given timestamp (inclusive)"
  accountingBookAsOf(
    "Accounting book ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingBook

  "Get paginated list of accounting presentations"
  accountingPresentationsPage(
    pagination: Pagination

    filters: AccountingPresentationFilters

    "Sort configuration"
    sort: [AccountingPresentationSortInput]
  ): AccountingPresentationPage

  "Get accounting presentation by ID"
  accountingPresentation(
    "Accounting presentation ID to fetch"
    id: ID!
  ): AccountingPresentation

  "Check if an accounting presentation can be deleted"
  canDeleteAccountingPresentation(
    "Accounting presentation ID to check"
    id: ID!
  ): CanDeleteAccountingPresentationPayload

  "Get paginated audit timeline for an accounting presentation with filters and sort"
  accountingPresentationTimelinePage(
    "Accounting presentation ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingPresentationTimelineFilters

    sort: [AccountingPresentationTimelineSortInput]
  ): AccountingPresentationTimelinePage

  "Get the state of an accounting presentation reconstructed at a specific version id"
  accountingPresentationAtVersion(
    "Accounting presentation ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingPresentation

  "Get the state of an accounting presentation reconstructed as of the given timestamp (inclusive)"
  accountingPresentationAsOf(
    "Accounting presentation ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingPresentation

  accountingSourcesPage(pagination: Pagination, filters: AccountingSourceFilters, sort: [AccountingSourceSortInput]): AccountingSourcePage

  accountingSource(id: ID!): AccountingSource

  canDeleteAccountingSource(id: ID!): CanDeleteAccountingSourcePayload

  "Get paginated audit timeline for an accounting source with filters and sort"
  accountingSourceTimelinePage(
    "Accounting source ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingSourceTimelineFilters

    sort: [AccountingSourceTimelineSortInput]
  ): AccountingSourceTimelinePage

  "Get the state of an accounting source reconstructed at a specific version id"
  accountingSourceAtVersion(
    "Accounting source ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingSource

  "Get the state of an accounting source reconstructed as of the given timestamp (inclusive)"
  accountingSourceAsOf(
    "Accounting source ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingSource

  "Get paginated list of accounting entities"
  accountingEntitiesPage(
    pagination: Pagination

    filters: AccountingEntityFilters

    "Sort configuration"
    sort: [AccountingEntitySortInput]
  ): AccountingEntityPage

  "Get accounting entity by ID"
  accountingEntity(
    "Accounting entity ID to fetch"
    id: ID!
  ): AccountingEntity

  "Get accounting entity by identification number"
  accountingEntityByIdentificationNumber(
    "Identification number to fetch"
    identificationNumber: String!
  ): AccountingEntity

  "Check if an accounting entity can be deleted"
  canDeleteAccountingEntity(
    "Accounting entity ID to check"
    id: ID!
  ): CanDeleteAccountingEntityPayload

  "Get paginated audit timeline for an accounting entity with filters and sort"
  accountingEntityTimelinePage(
    "Accounting entity ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingEntityTimelineFilters

    sort: [AccountingEntityTimelineSortInput]
  ): AccountingEntityTimelinePage

  "Get the state of an accounting entity reconstructed at a specific version id"
  accountingEntityAtVersion(
    "Accounting entity ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingEntity

  "Get the state of an accounting entity reconstructed as of the given timestamp (inclusive)"
  accountingEntityAsOf(
    "Accounting entity ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingEntity

  "Get paginated accounting entries"
  accountingEntriesPage(pagination: Pagination, filters: AccountingEntryFilters, sort: [AccountingEntrySortInput]): AccountingEntryPage

  "Get an accounting entry by id"
  accountingEntry(id: ID!): AccountingEntry

  "Get paginated accounting entry drafts"
  accountingEntryDraftsPage(
    pagination: Pagination, filters: AccountingEntryDraftFilters, sort: [AccountingEntryDraftSortInput]
  ): AccountingEntryDraftPage

  "Get an accounting entry draft by id"
  accountingEntryDraft(id: ID!): AccountingEntryDraft

  "Get paginated list of book tax types"
  taxCategoriesPage(pagination: Pagination, filters: TaxCategoryFilters): TaxCategoryPage

  "Get book tax type by ID"
  taxCategory(id: ID!): TaxCategory

  "Check if a tax category can be deleted"
  canDeleteTaxCategory(
    "Tax category ID to check"
    id: ID!
  ): CanDeleteTaxCategoryPayload

  "Get paginated audit timeline for a tax category with filters and sort"
  taxCategoryTimelinePage(
    "Tax category ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: TaxCategoryTimelineFilters

    sort: [TaxCategoryTimelineSortInput]
  ): TaxCategoryTimelinePage

  "Get the state of a tax category reconstructed at a specific version id"
  taxCategoryAtVersion(
    "Tax category ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): TaxCategory

  "Get the state of a tax category reconstructed as of the given timestamp (inclusive)"
  taxCategoryAsOf(
    "Tax category ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): TaxCategory

  "Get paginated list of taxes"
  taxesPage(pagination: Pagination, filters: TaxFilters): TaxPage

  "Get tax by ID"
  tax(id: ID!): Tax

  "Check if a tax can be deleted"
  canDeleteTax(
    "Tax ID to check"
    id: ID!
  ): CanDeleteTaxPayload

  "Get paginated audit timeline for a tax with filters and sort"
  taxTimelinePage(
    "Tax ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: TaxTimelineFilters

    sort: [TaxTimelineSortInput]
  ): TaxTimelinePage

  "Get the state of a tax reconstructed at a specific version id"
  taxAtVersion(
    "Tax ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Tax

  "Get the state of a tax reconstructed as of the given timestamp (inclusive)"
  taxAsOf(
    "Tax ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Tax

  "Get paginated list of accounting groups"
  accountingGroupsPage(pagination: Pagination, filters: AccountingGroupFilters): AccountingGroupPage

  "Get accounting group by ID"
  accountingGroup(id: ID!): AccountingGroup

  "Check if an accounting group can be deleted"
  canDeleteAccountingGroup(
    "Accounting group ID to check"
    id: ID!
  ): CanDeleteAccountingGroupPayload

  "Get paginated audit timeline for an accounting group with filters and sort"
  accountingGroupTimelinePage(
    "Accounting group ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingGroupTimelineFilters

    sort: [AccountingGroupTimelineSortInput]
  ): AccountingGroupTimelinePage

  "Get the state of an accounting group reconstructed at a specific version id"
  accountingGroupAtVersion(
    "Accounting group ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingGroup

  "Get the state of an accounting group reconstructed as of the given timestamp (inclusive)"
  accountingGroupAsOf(
    "Accounting group ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingGroup

  "Get paginated list of accounting account groups"
  accountingAccountGroupsPage(
    pagination: Pagination

    filters: AccountingAccountGroupFilters

    "Sort configuration"
    sort: [AccountingAccountGroupSortInput]
  ): AccountingAccountGroupPage

  "Get accounting account group by ID"
  accountingAccountGroup(
    "Accounting account group ID to fetch"
    id: ID!
  ): AccountingAccountGroup

  "Check if an accounting account group can be deleted"
  canDeleteAccountingAccountGroup(
    "Accounting account group ID to check"
    id: ID!
  ): CanDeleteAccountingAccountGroupPayload

  "Get paginated audit timeline for an accounting account group with filters and sort"
  accountingAccountGroupTimelinePage(
    "Accounting account group ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: AccountingAccountGroupTimelineFilters

    sort: [AccountingAccountGroupTimelineSortInput]
  ): AccountingAccountGroupTimelinePage

  "Get the state of an accounting account group reconstructed at a specific version id"
  accountingAccountGroupAtVersion(
    "Accounting account group ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): AccountingAccountGroup

  "Get the state of an accounting account group reconstructed as of the given timestamp (inclusive)"
  accountingAccountGroupAsOf(
    "Accounting account group ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AccountingAccountGroup

  "Get paginated list of payment methods"
  paymentMethodsPage(
    pagination: Pagination

    filters: PaymentMethodFilters

    "Sort configuration"
    sort: [PaymentMethodSortInput]
  ): PaymentMethodPage

  "Get payment method by ID"
  paymentMethod(
    "Payment method ID to fetch"
    id: ID!
  ): PaymentMethod

  "Get payment method by abbreviation"
  paymentMethodByAbbreviation(
    "Payment method abbreviation to fetch"
    abbreviation: String!
  ): PaymentMethod

  "Check if a payment method can be deleted"
  canDeletePaymentMethod(
    "Payment method ID to check"
    id: ID!
  ): CanDeletePaymentMethodPayload

  "Get paginated audit timeline for a payment method with filters and sort"
  paymentMethodTimelinePage(
    "Payment method ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: PaymentMethodTimelineFilters

    sort: [PaymentMethodTimelineSortInput]
  ): PaymentMethodTimelinePage

  "Get the state of a payment method reconstructed at a specific version id"
  paymentMethodAtVersion(
    "Payment method ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): PaymentMethod

  "Get the state of a payment method reconstructed as of the given timestamp (inclusive)"
  paymentMethodAsOf(
    "Payment method ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): PaymentMethod

  "Get paginated list of customers"
  customersPage(
    pagination: Pagination

    filters: CustomerFilters

    "Sort configuration"
    sort: [CustomerSortInput]
  ): CustomerPage

  "Get customer by ID"
  customer(
    "Customer ID to fetch"
    id: ID!
  ): Customer

  "Get customer by accounting entity ID"
  customerByAccountingEntityId(
    "Accounting entity ID to fetch"
    accountingEntityId: ID!
  ): Customer

  "Check if a customer can be deleted"
  canDeleteCustomer(
    "Customer ID to check"
    id: ID!
  ): CanDeleteCustomerPayload

  "Get paginated audit timeline for a customer with filters and sort"
  customerTimelinePage(
    "Customer ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: CustomerTimelineFilters

    sort: [CustomerTimelineSortInput]
  ): CustomerTimelinePage

  "Get the state of a customer reconstructed at a specific version id"
  customerAtVersion(
    "Customer ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Customer

  "Get the state of a customer reconstructed as of the given timestamp (inclusive)"
  customerAsOf(
    "Customer ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Customer

  "Get paginated list of sellers"
  sellersPage(
    pagination: Pagination

    filters: SellerFilters

    "Sort configuration"
    sort: [SellerSortInput]
  ): SellerPage

  "Get seller by ID"
  seller(
    "Seller ID to fetch"
    id: ID!
  ): Seller

  "Get seller by accounting entity ID"
  sellerByAccountingEntity(
    "Accounting entity ID to fetch seller for"
    accountingEntityId: ID!
  ): Seller

  "Check if a seller can be deleted"
  canDeleteSeller(
    "Seller ID to check"
    id: ID!
  ): CanDeleteSellerPayload

  "Get paginated audit timeline for a seller with filters and sort"
  sellerTimelinePage(
    "Seller ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: SellerTimelineFilters

    sort: [SellerTimelineSortInput]
  ): SellerTimelinePage

  "Get the state of a seller reconstructed at a specific version id"
  sellerAtVersion(
    "Seller ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Seller

  "Get the state of a seller reconstructed as of the given timestamp (inclusive)"
  sellerAsOf(
    "Seller ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Seller

  "Get paginated list of zones"
  zonesPage(
    pagination: Pagination

    filters: ZoneFilters

    "Sort configuration"
    sort: [ZoneSortInput]
  ): ZonePage

  "Get zone by ID"
  zone(
    "Zone ID to fetch"
    id: ID!
  ): Zone

  "Get zone by name"
  zoneByName(
    "Zone name to fetch"
    name: String!
  ): Zone

  "Check if a zone can be deleted"
  canDeleteZone(
    "Zone ID to check"
    id: ID!
  ): CanDeleteZonePayload

  "Get paginated audit timeline for a zone with filters and sort"
  zoneTimelinePage(
    "Zone ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ZoneTimelineFilters

    sort: [ZoneTimelineSortInput]
  ): ZoneTimelinePage

  "Get the state of a zone reconstructed at a specific version id"
  zoneAtVersion(
    "Zone ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Zone

  "Get the state of a zone reconstructed as of the given timestamp (inclusive)"
  zoneAsOf(
    "Zone ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Zone

  invoicesPage(pagination: Pagination, filters: InvoiceFilters, sort: [InvoiceSortInput]): InvoicePage

  invoice(id: ID!): Invoice

  additionalDiscountTypesPage(
    pagination: Pagination, filters: AdditionalDiscountTypeFilters, sort: [AdditionalDiscountTypeSortInput]
  ): AdditionalDiscountTypePage

  additionalDiscountType(id: ID!): AdditionalDiscountType

  "Check if an additional discount type can be deleted"
  canDeleteAdditionalDiscountType(
    "Additional discount type ID to check"
    id: ID!
  ): CanDeleteAdditionalDiscountTypePayload

  "Get paginated list of price lists"
  priceListsPage(
    pagination: Pagination

    filters: PriceListFilters

    "Sort configuration"
    sort: [PriceListSortInput]
  ): PriceListPage

  "Get price list by ID"
  priceList(
    "Price list ID to fetch"
    id: ID!
  ): PriceList

  "Check if a price list can be deleted"
  canDeletePriceList(
    "Price list ID to check"
    id: ID!
  ): CanDeletePriceListPayload

  "Get paginated audit timeline for a price list with filters and sort"
  priceListTimelinePage(
    "Price list ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: PriceListTimelineFilters

    sort: [PriceListTimelineSortInput]
  ): PriceListTimelinePage

  "Get the state of a price list reconstructed at a specific version id"
  priceListAtVersion(
    "Price list ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): PriceList

  "Get the state of a price list reconstructed as of the given timestamp (inclusive)"
  priceListAsOf(
    "Price list ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): PriceList

  "Get paginated list of suppliers"
  suppliersPage(pagination: Pagination, filters: SupplierFilters, sort: [SupplierSortInput]): SupplierPage

  "Get supplier by ID"
  supplier(id: ID!): Supplier

  "Get supplier by accounting entity ID"
  supplierByAccountingEntityId(
    "Accounting entity ID to fetch supplier for"
    accountingEntityId: ID!
  ): Supplier

  "Check if a supplier can be deleted"
  canDeleteSupplier(
    "Supplier ID to check"
    id: ID!
  ): CanDeleteSupplierPayload

  "Get paginated list of banks"
  banksPage(
    pagination: Pagination

    filters: BankFilters

    "Sort configuration"
    sort: [BankSortInput]
  ): BankPage

  "Get bank by ID"
  bank(
    "Bank ID to fetch"
    id: ID!
  ): Bank

  "Get bank by code"
  bankByCode(
    "Bank code to fetch"
    code: String!
  ): Bank

  "Get bank by accounting entity"
  bankByAccountingEntity(
    "Accounting entity ID to fetch bank for"
    accountingEntityId: ID!
  ): Bank

  "Check if a bank can be deleted"
  canDeleteBank(
    "Bank ID to check"
    id: ID!
  ): CanDeleteBankPayload

  "Get paginated audit timeline for a bank with filters and sort"
  bankTimelinePage(
    "Bank ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: BankTimelineFilters

    sort: [BankTimelineSortInput]
  ): BankTimelinePage

  "Get the state of a bank reconstructed at a specific version id"
  bankAtVersion(
    "Bank ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Bank

  "Get the state of a bank reconstructed as of the given timestamp (inclusive)"
  bankAsOf(
    "Bank ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Bank

  "Get paginated list of bank accounts"
  bankAccountsPage(
    pagination: Pagination

    filters: BankAccountFilters

    "Sort configuration"
    sort: [BankAccountSortInput]
  ): BankAccountPage

  "Get bank account by ID"
  bankAccount(
    "Bank account ID to fetch"
    id: ID!
  ): BankAccount

  "Get bank account by number"
  bankAccountByNumber(
    "Bank account number to fetch"
    number: String!
  ): BankAccount

  "Check if a bank account can be deleted"
  canDeleteBankAccount(
    "Bank account ID to check"
    id: ID!
  ): CanDeleteBankAccountPayload

  "Get paginated audit timeline for a bank account with filters and sort"
  bankAccountTimelinePage(
    "Bank account ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: BankAccountTimelineFilters

    sort: [BankAccountTimelineSortInput]
  ): BankAccountTimelinePage

  "Get the state of a bank account reconstructed at a specific version id"
  bankAccountAtVersion(
    "Bank account ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): BankAccount

  "Get the state of a bank account reconstructed as of the given timestamp (inclusive)"
  bankAccountAsOf(
    "Bank account ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): BankAccount

  "Get paginated list of cash drawers"
  cashDrawersPage(
    pagination: Pagination

    filters: CashDrawerFilters

    "Sort configuration"
    sort: [CashDrawerSortInput]
  ): CashDrawerPage

  "Get cash drawer by ID"
  cashDrawer(
    "Cash drawer ID to fetch"
    id: ID!
  ): CashDrawer

  "Check if a cash drawer can be deleted"
  canDeleteCashDrawer(
    "Cash drawer ID to check"
    id: ID!
  ): CanDeleteCashDrawerPayload

  "Get paginated audit timeline for a cash drawer with filters and sort"
  cashDrawerTimelinePage(
    "Cash drawer ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: CashDrawerTimelineFilters

    sort: [CashDrawerTimelineSortInput]
  ): CashDrawerTimelinePage

  "Get the state of a cash drawer reconstructed at a specific version id"
  cashDrawerAtVersion(
    "Cash drawer ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): CashDrawer

  "Get the state of a cash drawer reconstructed as of the given timestamp (inclusive)"
  cashDrawerAsOf(
    "Cash drawer ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): CashDrawer

  franchisesPage(
    pagination: Pagination

    filters: FranchiseFilters

    "Sort configuration"
    sort: [FranchiseSortInput]
  ): FranchisePage

  franchise(
    "Franchise ID to fetch"
    id: ID!
  ): Franchise

  canDeleteFranchise(
    "Franchise ID to check"
    id: ID!
  ): CanDeleteFranchisePayload

  franchiseTimelinePage(
    "Franchise ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: FranchiseTimelineFilters

    sort: [FranchiseTimelineSortInput]
  ): FranchiseTimelinePage

  franchiseAtVersion(
    "Franchise ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Franchise

  franchiseAsOf(
    "Franchise ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Franchise

  "Get paginated list of concepts"
  treasuryConceptsPage(
    pagination: Pagination

    filters: TreasuryConceptFilters

    "Sort configuration"
    sort: [TreasuryConceptSortInput]
  ): TreasuryConceptPage

  "Get concept by ID"
  treasuryConcept(
    "Concept ID to fetch"
    id: ID!
  ): TreasuryConcept

  "Check if a concept can be deleted"
  canDeleteTreasuryConcept(
    "Concept ID to check"
    id: ID!
  ): CanDeleteTreasuryConceptPayload

  "Get paginated audit timeline for a concept with filters and sort"
  treasuryConceptTimelinePage(
    "Concept ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: TreasuryConceptTimelineFilters

    sort: [TreasuryConceptTimelineSortInput]
  ): TreasuryConceptTimelinePage

  "Get the state of a concept reconstructed at a specific version id"
  treasuryConceptAtVersion(
    "Concept ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): TreasuryConcept

  "Get the state of a concept reconstructed as of the given timestamp (inclusive)"
  treasuryConceptAsOf(
    "Concept ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): TreasuryConcept

  treasuryConfig: TreasuryConfig

  treasuryConfigTimelinePage(
    id: ID!, pagination: Pagination, filters: TreasuryConfigTimelineFilters, sort: [TreasuryConfigTimelineSortInput]
  ): TreasuryConfigTimelinePage

  treasuryConfigAtVersion(id: ID!, versionId: ID!): TreasuryConfig

  treasuryConfigAsOf(id: ID!, at: IsoDatetime!): TreasuryConfig

  "Get paginated list of measurement units"
  measurementUnitsPage(pagination: Pagination, filters: MeasurementUnitFilters, sort: [MeasurementUnitSortInput]): MeasurementUnitPage

  "Get measurement unit by ID"
  measurementUnit(id: ID!): MeasurementUnit

  "Check if a measurement unit can be deleted"
  canDeleteMeasurementUnit(
    "Measurement Unit ID to check"
    id: ID!
  ): CanDeleteMeasurementUnitPayload

  "Get a paginated audit timeline for a MeasurementUnit"
  measurementUnitTimelinePage(
    "MeasurementUnit ID"
    id: ID!

    pagination: Pagination

    filters: MeasurementUnitTimelineFilters

    "Sort configuration"
    sort: [MeasurementUnitTimelineSortInput]
  ): MeasurementUnitTimelinePage

  "Reconstruct MeasurementUnit at a specific audit version"
  measurementUnitAtVersion(id: ID!, versionId: ID!): MeasurementUnit

  "Reconstruct MeasurementUnit as of a timestamp"
  measurementUnitAsOf(id: ID!, at: IsoDatetime!): MeasurementUnit

  "Get paginated list of item types"
  itemTypesPage(pagination: Pagination, filters: ItemTypeFilters, sort: [ItemTypeSortInput]): ItemTypePage

  "Get item type by ID"
  itemType(id: ID!): ItemType

  "Check if an item type can be deleted"
  canDeleteItemType(
    "Item type ID to check"
    id: ID!
  ): CanDeleteItemTypePayload

  "Get paginated audit timeline for an item type with filters and sort"
  itemTypeTimelinePage(
    "Item type ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ItemTypeTimelineFilters

    sort: [ItemTypeTimelineSortInput]
  ): ItemTypeTimelinePage

  "Get the state of an item type reconstructed at a specific version id"
  itemTypeAtVersion(
    "Item type ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): ItemType

  "Get the state of an item type reconstructed as of the given timestamp (inclusive)"
  itemTypeAsOf(
    "Item type ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): ItemType

  "List images by item"
  imagesByItemByItem(itemId: ID!): [ImageByItem]

  "List components by parent item"
  componentsByItemByParent(parentItemId: ID!): [ComponentsByItem]

  "Get paginated list of item categories"
  itemCategoriesPage(pagination: Pagination, filters: ItemCategoryFilters, sort: [ItemCategorySortInput]): ItemCategoryPage

  "Get item category by ID"
  itemCategory(id: ID!): ItemCategory

  "Check if an item category can be deleted"
  canDeleteItemCategory(
    "Item category ID to check"
    id: ID!
  ): CanDeleteItemCategoryPayload

  "Get paginated audit timeline for an item category with filters and sort"
  itemCategoryTimelinePage(
    "Item category ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ItemCategoryTimelineFilters

    sort: [ItemCategoryTimelineSortInput]
  ): ItemCategoryTimelinePage

  "Get the state of an item category reconstructed at a specific version id"
  itemCategoryAtVersion(
    "Item category ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): ItemCategory

  "Get the state of an item category reconstructed as of the given timestamp (inclusive)"
  itemCategoryAsOf(
    "Item category ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): ItemCategory

  "Get paginated list of item sub categories"
  itemSubCategoriesPage(pagination: Pagination, filters: ItemSubCategoryFilters, sort: [ItemSubCategorySortInput]): ItemSubCategoryPage

  "Get item sub category by ID"
  itemSubCategory(id: ID!): ItemSubCategory

  "Check if an item sub category can be deleted"
  canDeleteItemSubCategory(
    "Item sub category ID to check"
    id: ID!
  ): CanDeleteItemSubCategoryPayload

  "Get paginated audit timeline for an item sub category with filters and sort"
  itemSubCategoryTimelinePage(
    "Item sub category ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ItemSubCategoryTimelineFilters

    sort: [ItemSubCategoryTimelineSortInput]
  ): ItemSubCategoryTimelinePage

  "Get the state of an item sub category reconstructed at a specific version id"
  itemSubCategoryAtVersion(
    "Item sub category ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): ItemSubCategory

  "Get the state of an item sub category reconstructed as of the given timestamp (inclusive)"
  itemSubCategoryAsOf(
    "Item sub category ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): ItemSubCategory

  "Get paginated list of item brands"
  itemBrandsPage(pagination: Pagination, filters: ItemBrandFilters, sort: [ItemBrandSortInput]): ItemBrandPage

  "Get item brand by ID"
  itemBrand(id: ID!): ItemBrand

  "Get a paginated audit timeline for an ItemBrand"
  itemBrandTimelinePage(
    "ItemBrand ID"
    id: ID!

    pagination: Pagination

    filters: ItemBrandTimelineFilters

    "Sort configuration"
    sort: [ItemBrandTimelineSortInput]
  ): ItemBrandTimelinePage

  "Reconstruct ItemBrand at a specific audit version"
  itemBrandAtVersion(id: ID!, versionId: ID!): ItemBrand

  "Reconstruct ItemBrand as of a timestamp"
  itemBrandAsOf(id: ID!, at: IsoDatetime!): ItemBrand

  "Check if an item brand can be deleted"
  canDeleteItemBrand(
    "Item brand ID to check"
    id: ID!
  ): CanDeleteItemBrandPayload

  "Get paginated list of item size categories"
  itemSizeCategoriesPage(pagination: Pagination, filters: ItemSizeCategoryFilters, sort: [ItemSizeCategorySortInput]): ItemSizeCategoryPage

  "Get item size category by ID"
  itemSizeCategory(id: ID!): ItemSizeCategory

  "Check if an item size category can be deleted"
  canDeleteItemSizeCategory(
    "Item size category ID to check"
    id: ID!
  ): CanDeleteItemSizeCategoryPayload

  "Get paginated audit timeline for an item size category with filters and sort"
  itemSizeCategoryTimelinePage(
    "Item size category ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ItemSizeCategoryTimelineFilters

    sort: [ItemSizeCategoryTimelineSortInput]
  ): ItemSizeCategoryTimelinePage

  "Get the state of an item size category reconstructed at a specific version id"
  itemSizeCategoryAtVersion(
    "Item size category ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): ItemSizeCategory

  "Get the state of an item size category reconstructed as of the given timestamp (inclusive)"
  itemSizeCategoryAsOf(
    "Item size category ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): ItemSizeCategory

  "Get paginated list of item size values"
  itemSizeValuesPage(pagination: Pagination, filters: ItemSizeValueFilters, sort: [ItemSizeValueSortInput]): ItemSizeValuePage

  "Get item size value by ID"
  itemSizeValue(id: ID!): ItemSizeValue

  "Check if an item size value can be deleted"
  canDeleteItemSizeValue(
    "Item size value ID to check"
    id: ID!
  ): CanDeleteItemSizeValuePayload

  "Get paginated audit timeline for an item size value with filters and sort"
  itemSizeValueTimelinePage(
    "Item size value ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ItemSizeValueTimelineFilters

    sort: [ItemSizeValueTimelineSortInput]
  ): ItemSizeValueTimelinePage

  "Get the state of an item size value reconstructed at a specific version id"
  itemSizeValueAtVersion(
    "Item size value ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): ItemSizeValue

  "Get the state of an item size value reconstructed as of the given timestamp (inclusive)"
  itemSizeValueAsOf(
    "Item size value ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): ItemSizeValue

  "Get paginated list of items"
  itemsPage(pagination: Pagination, filters: ItemFilters, sort: [ItemSortInput]): ItemPage

  "Get item by ID"
  item(id: ID!): Item

  "Check if an item can be deleted"
  canDeleteItem(
    "Item ID to check"
    id: ID!
  ): CanDeleteItemPayload

  "Get paginated audit timeline for an item with filters and sort"
  itemTimelinePage(
    "Item ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: ItemTimelineFilters

    sort: [ItemTimelineSortInput]
  ): ItemTimelinePage

  "Get the state of an item reconstructed at a specific version id"
  itemAtVersion(
    "Item ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Item

  "Get the state of an item reconstructed as of the given timestamp (inclusive)"
  itemAsOf(
    "Item ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Item

  "Get paginated list of lots"
  lotsPage(pagination: Pagination, filters: LotFilters, sort: [LotSortInput]): LotPage

  "Get lot by ID"
  lot(id: ID!): Lot

  "Check if a lot can be deleted"
  canDeleteLot(
    "Lot ID to check"
    id: ID!
  ): CanDeleteLotPayload

  "Get paginated list of document sequences"
  documentSequencesPage(
    pagination: Pagination

    filters: DocumentSequenceFilters

    "Sort configuration"
    sort: [DocumentSequenceSortInput]
  ): DocumentSequencePage

  "Get document sequence by ID"
  documentSequence(
    "Document sequence ID to fetch"
    id: ID!
  ): DocumentSequence

  "Check if a DocumentSequence can be deleted"
  canDeleteDocumentSequence(
    "DocumentSequence ID to check"
    id: ID!
  ): CanDeleteDocumentSequencePayload

  "Audit timeline for a DocumentSequence"
  documentSequenceTimelinePage(
    "DocumentSequence ID"
    id: ID!

    pagination: Pagination

    filters: DocumentSequenceTimelineFilters

    sort: [DocumentSequenceTimelineSortInput]
  ): DocumentSequenceTimelinePage

  "Reconstruct DocumentSequence at a specific version"
  documentSequenceAtVersion(
    "DocumentSequence ID"
    id: ID!

    "Version ID"
    versionId: ID!
  ): DocumentSequence

  "Reconstruct DocumentSequence as of a timestamp"
  documentSequenceAsOf(
    "DocumentSequence ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): DocumentSequence

  "Get document sequence monthly by ID"
  documentSequenceMonthly(
    "Document sequence monthly ID to fetch"
    id: ID!
  ): DocumentSequenceMonthly

  "Get paginated list of document sequence monthly rows"
  documentSequenceMonthlyPage(
    pagination: Pagination

    filters: DocumentSequenceMonthlyFilters

    "Sort configuration"
    sort: [DocumentSequenceMonthlySortInput]
  ): DocumentSequenceMonthlyPage

  "Get paginated list of authorization sequence types"
  authorizationSequenceTypesPage(
    pagination: Pagination

    filters: AuthorizationSequenceTypeFilters

    "Sort configuration"
    sort: [AuthorizationSequenceTypeSortInput]
  ): AuthorizationSequenceTypePage

  "Get an authorization sequence type by ID"
  authorizationSequenceType(
    "Authorization sequence type ID to fetch"
    id: ID!
  ): AuthorizationSequenceType

  "Check if an authorization sequence type can be deleted"
  canDeleteAuthorizationSequenceType(
    "Authorization sequence type ID to check"
    id: ID!
  ): CanDeleteAuthorizationSequenceTypePayload

  "Get a paginated audit timeline for an AuthorizationSequenceType"
  authorizationSequenceTypeTimelinePage(
    "Authorization sequence type ID"
    id: ID!

    pagination: Pagination

    filters: AuthorizationSequenceTypeTimelineFilters

    "Sort configuration"
    sort: [AuthorizationSequenceTypeTimelineSortInput]
  ): AuthorizationSequenceTypeTimelinePage

  "Reconstruct AuthorizationSequenceType at a specific audit version"
  authorizationSequenceTypeAtVersion(id: ID!, versionId: ID!): AuthorizationSequenceType

  "Reconstruct AuthorizationSequenceType as of a timestamp"
  authorizationSequenceTypeAsOf(id: ID!, at: IsoDatetime!): AuthorizationSequenceType

  "Get paginated list of authorization sequences"
  authorizationSequencesPage(
    pagination: Pagination

    filters: AuthorizationSequenceFilters

    "Sort configuration"
    sort: [AuthorizationSequenceSortInput]
  ): AuthorizationSequencePage

  "Get an authorization sequence by ID"
  authorizationSequence(
    "Authorization sequence ID to fetch"
    id: ID!
  ): AuthorizationSequence

  "Check if an authorization sequence can be deleted"
  canDeleteAuthorizationSequence(
    "Authorization sequence ID to check"
    id: ID!
  ): CanDeleteAuthorizationSequencePayload

  "Audit timeline for an Authorization Sequence"
  authorizationSequenceTimelinePage(
    "Authorization Sequence ID"
    id: ID!

    pagination: Pagination

    filters: AuthorizationSequenceTimelineFilters

    sort: [AuthorizationSequenceTimelineSortInput]
  ): AuthorizationSequenceTimelinePage

  "Reconstruct Authorization Sequence at a specific version"
  authorizationSequenceAtVersion(
    "Authorization Sequence ID"
    id: ID!

    "Version ID"
    versionId: ID!
  ): AuthorizationSequence

  "Reconstruct Authorization Sequence as of a timestamp"
  authorizationSequenceAsOf(
    "Authorization Sequence ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): AuthorizationSequence

  "Get paginated list of inventory catalogs"
  catalogsPage(pagination: Pagination, filters: CatalogFilters, sort: [CatalogSortInput]): CatalogPage

  "Get catalog by ID"
  catalog(id: ID!): Catalog

  "Get catalog by name"
  getCatalogByName(name: String!): Catalog

  "Check if a catalog can be deleted"
  canDeleteCatalog(
    "Catalog ID to check"
    id: ID!
  ): CanDeleteCatalogPayload

  "Get a paginated audit timeline for a Catalog"
  catalogTimelinePage(
    "Catalog ID"
    id: ID!

    pagination: Pagination

    filters: CatalogTimelineFilters

    "Sort configuration"
    sort: [CatalogTimelineSortInput]
  ): CatalogTimelinePage

  "Reconstruct Catalog at a specific audit version"
  catalogAtVersion(id: ID!, versionId: ID!): Catalog

  "Reconstruct Catalog as of a timestamp"
  catalogAsOf(id: ID!, at: IsoDatetime!): Catalog

  "Get paginated list of withholding certificates"
  withholdingCertificatesPage(
    pagination: Pagination, filters: WithholdingCertificateFilters, sort: [WithholdingCertificateSortInput]
  ): WithholdingCertificatePage

  "Get withholding certificate by ID"
  withholdingCertificate(id: ID!): WithholdingCertificate

  "Check if a withholding certificate can be deleted"
  canDeleteWithholdingCertificate(
    "Withholding certificate ID to check"
    id: ID!
  ): CanDeleteWithholdingCertificatePayload

  "Get paginated audit timeline for a withholding certificate with filters and sort"
  withholdingCertificateTimelinePage(
    "Withholding certificate ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: WithholdingCertificateTimelineFilters

    sort: [WithholdingCertificateTimelineSortInput]
  ): WithholdingCertificateTimelinePage

  "Get the state of a withholding certificate reconstructed at a specific version id"
  withholdingCertificateAtVersion(
    "Withholding certificate ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): WithholdingCertificate

  "Get the state of a withholding certificate reconstructed as of the given timestamp (inclusive)"
  withholdingCertificateAsOf(
    "Withholding certificate ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): WithholdingCertificate

  "Get paginated list of withholding types"
  withholdingTypesPage(pagination: Pagination, filters: WithholdingTypeFilters, sort: [WithholdingTypeSortInput]): WithholdingTypePage

  "Get withholding type by ID"
  withholdingType(id: ID!): WithholdingType

  "Get paginated audit timeline for a withholding type with filters and sort"
  withholdingTypeTimelinePage(
    id: ID!, pagination: Pagination, filters: WithholdingTypeTimelineFilters, sort: [WithholdingTypeTimelineSortInput]
  ): WithholdingTypeTimelinePage

  "Get the state of a withholding type reconstructed at a specific version id"
  withholdingTypeAtVersion(id: ID!, versionId: ID!): WithholdingType

  "Get the state of a withholding type reconstructed as of the given timestamp (inclusive)"
  withholdingTypeAsOf(id: ID!, at: IsoDatetime!): WithholdingType

  "Get paginated list of emails"
  emailsPage(
    pagination: Pagination

    filters: EmailFilters

    "Sort configuration"
    sort: [EmailSortInput]
  ): EmailPage

  "Get email by ID"
  email(
    "Email ID to fetch"
    id: ID!
  ): Email

  "Check if an email can be deleted"
  canDeleteEmail(
    "Email ID to check"
    id: ID!
  ): CanDeleteEmailPayload

  "Get paginated audit timeline for an email with filters and sort"
  emailTimelinePage(
    "Email ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: EmailTimelineFilters

    sort: [EmailTimelineSortInput]
  ): EmailTimelinePage

  "Get the state of an email reconstructed at a specific version id"
  emailAtVersion(
    "Email ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Email

  "Get the state of an email reconstructed as of the given timestamp (inclusive)"
  emailAsOf(
    "Email ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Email

  "Get paginated list of SMTP servers"
  smtpsPage(
    pagination: Pagination

    filters: SmtpFilters

    "Sort configuration"
    sort: [SmtpSortInput]
  ): SmtpPage

  "Get SMTP by ID"
  smtp(
    "SMTP ID to fetch"
    id: ID!
  ): Smtp

  "Check if an SMTP can be deleted"
  canDeleteSmtp(
    "SMTP ID to check"
    id: ID!
  ): CanDeleteSmtpPayload

  "Get a paginated audit timeline for an SMTP"
  smtpTimelinePage(
    "SMTP ID"
    id: ID!

    pagination: Pagination

    filters: SmtpTimelineFilters

    "Sort configuration"
    sort: [SmtpTimelineSortInput]
  ): SmtpTimelinePage

  "Reconstruct SMTP at a specific audit version"
  smtpAtVersion(id: ID!, versionId: ID!): Smtp

  "Reconstruct SMTP as of a timestamp"
  smtpAsOf(id: ID!, at: IsoDatetime!): Smtp

  "Get paginated list of AWS S3 configs"
  awsS3ConfigsPage(pagination: Pagination, filters: AwsS3ConfigFilters, sort: [AwsS3ConfigSortInput]): AwsS3ConfigPage

  "Get AWS S3 config by ID"
  awsS3Config(id: ID!): AwsS3Config

  "Check if AWS S3 config can be deleted"
  canDeleteAwsS3Config(id: ID!): CanDeleteAwsS3ConfigPayload

  "Get paginated audit timeline for an AWS S3 config"
  awsS3ConfigTimelinePage(
    id: ID!, pagination: Pagination, filters: AwsS3ConfigTimelineFilters, sort: [AwsS3ConfigTimelineSortInput]
  ): AwsS3ConfigTimelinePage

  "Get the state of an AWS S3 config at a specific version"
  awsS3ConfigAtVersion(id: ID!, versionId: ID!): AwsS3Config

  "Get the state of an AWS S3 config as of a timestamp (inclusive)"
  awsS3ConfigAsOf(id: ID!, at: IsoDatetime!): AwsS3Config

  "Lista las configuraciones DIAN activas\/inactivas de la empresa"
  dianSoftwareConfigs: [DianSoftwareConfig]

  "Obtiene una configuracin DIAN por ID"
  dianSoftwareConfig(id: ID!): DianSoftwareConfig

  "Obtiene la configuracin DIAN activa por entorno y categora"
  activeDianSoftwareConfig(environment: DianEnvironment!, documentCategory: DianDocumentCategory!): DianSoftwareConfig

  "Obtiene el certificado DIAN activo de la empresa"
  activeDianCertificate: DianCertificate

  "Obtiene un certificado DIAN por ID"
  dianCertificate(id: ID!): DianCertificate

  "Get paginated list of currencies"
  currenciesPage(
    pagination: Pagination

    filters: CurrencyFilters

    "Sort configuration"
    sort: [CurrencySortInput]
  ): CurrencyPage

  "Get currency by ID"
  currency(
    "Currency ID to fetch"
    id: ID!
  ): Currency

  "Get currency by code"
  currencyByCode(
    "Currency code to fetch"
    code: String!
  ): Currency

  "Get a paginated audit timeline for a Currency"
  currencyTimelinePage(
    "Currency ID"
    id: ID!

    pagination: Pagination

    filters: CurrencyTimelineFilters

    "Sort configuration"
    sort: [CurrencyTimelineSortInput]
  ): CurrencyTimelinePage

  "Get Currency at a specific version"
  currencyAtVersion(id: ID!, versionId: ID!): Currency

  "Get Currency as of a specific timestamp"
  currencyAsOf(id: ID!, at: IsoDatetime!): Currency

  "Get max string lengths for entity fields. Filter by entities, domains, or get all."
  stringLengths(
    "Entity names (e.g., [\"customer\", \"seller\"])"
    entities: [String!]

    "Domain names (e.g., [\"billing\", \"treasury\"])"
    domains: [String!]
  ): [EntityStringLengths!]!

  "Get paginated list of buildings"
  buildingsPage(pagination: Pagination, filters: BuildingFilters, sort: [BuildingSortInput]): BuildingPage

  "Get building by ID"
  building(id: ID!): Building

  "Check if a building can be deleted"
  canDeleteBuilding(
    "Building ID to check"
    id: ID!
  ): CanDeleteBuildingPayload

  "Get paginated audit timeline for a building with filters and sort"
  buildingTimelinePage(
    "Building ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: BuildingTimelineFilters

    sort: [BuildingTimelineSortInput]
  ): BuildingTimelinePage

  "Get the state of a building reconstructed at a specific version id"
  buildingAtVersion(
    "Building ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Building

  "Get the state of a building reconstructed as of the given timestamp (inclusive)"
  buildingAsOf(
    "Building ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Building

  "Get paginated list of towers"
  towersPage(pagination: Pagination, filters: TowerFilters, sort: [TowerSortInput]): TowerPage

  "Get tower by ID"
  tower(id: ID!): Tower

  "Check if a tower can be deleted"
  canDeleteTower(
    "Tower ID to check"
    id: ID!
  ): CanDeleteTowerPayload

  "Get paginated audit timeline for a tower with filters and sort"
  towerTimelinePage(
    "Tower ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: TowerTimelineFilters

    sort: [TowerTimelineSortInput]
  ): TowerTimelinePage

  "Get the state of a tower reconstructed at a specific version id"
  towerAtVersion(
    "Tower ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Tower

  "Get the state of a tower reconstructed as of the given timestamp (inclusive)"
  towerAsOf(
    "Tower ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Tower

  "Get paginated list of floors"
  floorsPage(pagination: Pagination, filters: FloorFilters, sort: [FloorSortInput]): FloorPage

  "Get floor by ID"
  floor(id: ID!): Floor

  "Check if a floor can be deleted"
  canDeleteFloor(
    "Floor ID to check"
    id: ID!
  ): CanDeleteFloorPayload

  "Get paginated audit timeline for a floor with filters and sort"
  floorTimelinePage(
    "Floor ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: FloorTimelineFilters

    sort: [FloorTimelineSortInput]
  ): FloorTimelinePage

  "Get the state of a floor reconstructed at a specific version id"
  floorAtVersion(
    "Floor ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Floor

  "Get the state of a floor reconstructed as of the given timestamp (inclusive)"
  floorAsOf(
    "Floor ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Floor

  "Get paginated list of units"
  unitsPage(pagination: Pagination, filters: UnitFilters, sort: [UnitSortInput]): UnitPage

  "Get unit by ID"
  unit(id: ID!): Unit

  "Check if a unit can be deleted"
  canDeleteUnit(
    "Unit ID to check"
    id: ID!
  ): CanDeleteUnitPayload

  "Get paginated audit timeline for a unit with filters and sort"
  unitTimelinePage(
    "Unit ID to fetch timeline for"
    id: ID!

    pagination: Pagination

    filters: UnitTimelineFilters

    sort: [UnitTimelineSortInput]
  ): UnitTimelinePage

  "Get the state of a unit reconstructed at a specific version id"
  unitAtVersion(
    "Unit ID"
    id: ID!

    "Audit version ID"
    versionId: ID!
  ): Unit

  "Get the state of a unit reconstructed as of the given timestamp (inclusive)"
  unitAsOf(
    "Unit ID"
    id: ID!

    "Timestamp (inclusive)"
    at: IsoDatetime!
  ): Unit

  "Get paginated list of unit billing schedules"
  unitBillingSchedulesPage(pagination: Pagination, filters: UnitBillingScheduleFilters): UnitBillingSchedulePage

  "Get unit billing schedule by ID"
  unitBillingSchedule(id: ID!): UnitBillingSchedule

  "Get paginated list of lines by filters"
  unitBillingScheduleLinesPage(pagination: Pagination, filters: UnitBillingScheduleLineFilters!): UnitBillingScheduleLinePage

  "Get unit billing schedule line by ID"
  unitBillingScheduleLine(id: ID!): UnitBillingScheduleLine

  "Get paginated list of line taxes by filters"
  unitBillingScheduleLineTaxesPage(pagination: Pagination, filters: UnitBillingScheduleLineTaxFilters!): UnitBillingScheduleLineTaxPage

  "Get unit billing schedule line tax by ID"
  unitBillingScheduleLineTax(id: ID!): UnitBillingScheduleLineTax

  "Get paginated list of line discounts by filters"
  unitBillingScheduleLineDiscountsPage(pagination: Pagination, filters: UnitBillingScheduleLineDiscountFilters!): UnitBillingScheduleLineDiscountPage

  "Get unit billing schedule line discount by ID"
  unitBillingScheduleLineDiscount(id: ID!): UnitBillingScheduleLineDiscount
}

"queries relacionadas a la gestion de los repos(conexiones) de los clientes"
type RootMutationType {
  "Invalidate server configuration cache and remove dynamic repo"
  invalidateRepoConfig(input: InvalidateRepoConfigInput!): InvalidateRepoConfigPayload

  "Create a new country"
  createCountry(
    "Country data"
    input: CreateCountryInput!
  ): CreateCountryPayload

  "Update an existing country"
  updateCountry(
    "Country ID to update"
    id: ID!

    "Data to update"
    data: UpdateCountryInput!
  ): UpdateCountryPayload

  "Delete a country"
  deleteCountry(
    "Country ID to delete"
    id: ID!
  ): DeleteCountryPayload

  "Create a new city"
  createCity(
    "City data"
    input: CreateCityInput!
  ): CreateCityPayload

  "Update an existing city"
  updateCity(
    "City ID to update"
    id: ID!

    "Data to update"
    data: UpdateCityInput!
  ): UpdateCityPayload

  "Delete a city"
  deleteCity(
    "City ID to delete"
    id: ID!
  ): DeleteCityPayload

  "Create a new department"
  createDepartment(
    "Department data"
    input: CreateDepartmentInput!
  ): CreateDepartmentPayload

  "Update an existing department"
  updateDepartment(
    "Department ID to update"
    id: ID!

    "Data to update"
    data: UpdateDepartmentInput!
  ): UpdateDepartmentPayload

  "Delete a department"
  deleteDepartment(
    "Department ID to delete"
    id: ID!
  ): DeleteDepartmentPayload

  "Create a new company with its accounting entity"
  createCompany(
    "Company and entity data"
    input: CreateCompanyInput!
  ): CreateCompanyPayload

  "Update a company"
  updateCompany(
    "Company ID"
    id: ID!

    "Company update data"
    data: UpdateCompanyInput!
  ): UpdateCompanyPayload

  "Delete a company (archive)"
  deleteCompany(
    "Company ID"
    id: ID!
  ): DeleteCompanyPayload

  "Change the accounting entity linked to a company"
  changeCompanyEntity(
    "Company ID"
    companyId: ID!

    "Accounting entity ID to link"
    accountingEntityId: ID!
  ): CompanyMutationPayload

  "Change the accounting entity linked to the current company (from header)"
  changeCurrentCompanyEntity(
    "Accounting entity ID to link"
    accountingEntityId: ID!
  ): CompanyMutationPayload

  "Create a new company location"
  createCompanyLocation(
    "Company location data"
    input: CreateCompanyLocationInput!
  ): CreateCompanyLocationPayload

  "Update an existing company location"
  updateCompanyLocation(
    "Company location ID to update"
    id: ID!

    "Data to update"
    data: UpdateCompanyLocationInput!
  ): UpdateCompanyLocationPayload

  "Delete a company location"
  deleteCompanyLocation(
    "Company location ID to delete"
    id: ID!
  ): DeleteCompanyLocationPayload

  "Create a new storage"
  createStorage(
    "Storage data"
    input: CreateStorageInput!
  ): CreateStoragePayload

  "Update an existing storage"
  updateStorage(
    "Storage ID to update"
    id: ID!

    "Data to update"
    data: UpdateStorageInput!
  ): UpdateStoragePayload

  "Delete a storage"
  deleteStorage(
    "Storage ID to delete"
    id: ID!
  ): DeleteStoragePayload

  "Create a new cost center"
  createCostCenter(
    "Cost center data"
    input: CreateCostCenterInput!
  ): CreateCostCenterPayload

  "Update an existing cost center"
  updateCostCenter(
    "Cost center ID to update"
    id: ID!

    "Data to update"
    data: UpdateCostCenterInput!
  ): UpdateCostCenterPayload

  "Delete a cost center"
  deleteCostCenter(
    "Cost center ID to delete"
    id: ID!
  ): DeleteCostCenterPayload

  "Create a new module"
  createModule(
    "Module data"
    input: CreateModuleInput!
  ): CreateModulePayload

  "Update an existing module"
  updateModule(
    "Module ID to update"
    id: ID!

    "Data to update"
    data: UpdateModuleInput!
  ): UpdateModulePayload

  "Delete a module"
  deleteModule(
    "Module ID to delete"
    id: ID!
  ): DeleteModulePayload

  "Create a new process type"
  createProcessType(
    "Process type data"
    input: CreateProcessTypeInput!
  ): CreateProcessTypePayload

  "Update an existing process type"
  updateProcessType(
    "Process type ID to update"
    id: ID!

    "Data to update"
    data: UpdateProcessTypeInput!
  ): UpdateProcessTypePayload

  "Delete a process type"
  deleteProcessType(
    "Process type ID to delete"
    id: ID!
  ): DeleteProcessTypePayload

  "Create a new identification type"
  createIdentificationType(
    "Identification type data"
    input: CreateIdentificationTypeInput!
  ): CreateIdentificationTypePayload

  "Update an existing identification type"
  updateIdentificationType(
    "Identification type ID to update"
    id: ID!

    "Data to update"
    data: UpdateIdentificationTypeInput!
  ): UpdateIdentificationTypePayload

  "Delete an identification type"
  deleteIdentificationType(
    "Identification type ID to delete"
    id: ID!
  ): DeleteIdentificationTypePayload

  "Create a new accounting account"
  createAccountingAccount(
    "Accounting account data"
    input: CreateAccountingAccountInput!
  ): CreateAccountingAccountPayload

  "Update an existing accounting account"
  updateAccountingAccount(
    "Accounting account ID to update"
    id: ID!

    "Data to update"
    data: UpdateAccountingAccountInput!
  ): UpdateAccountingAccountPayload

  "Transactional bulk create accounting accounts (all-or-nothing)"
  createAccountingAccounts(
    "List of accounting account data to create in a single transaction"
    input: [CreateAccountingAccountInput!]!
  ): CreateAccountingAccountsPayload

  "Delete an accounting account"
  deleteAccountingAccount(
    "Accounting account ID to delete"
    id: ID!
  ): DeleteAccountingAccountPayload

  createAccountingSource(input: CreateAccountingSourceInput!): CreateAccountingSourcePayload

  updateAccountingSource(id: ID!, data: UpdateAccountingSourceInput!): UpdateAccountingSourcePayload

  deleteAccountingSource(id: ID!): DeleteAccountingSourcePayload

  "Create a new accounting book"
  createAccountingBook(
    "Accounting book data"
    input: CreateAccountingBookInput!
  ): CreateAccountingBookPayload

  "Update an existing accounting book"
  updateAccountingBook(
    "Accounting book ID to update"
    id: ID!

    "Data to update"
    data: UpdateAccountingBookInput!
  ): UpdateAccountingBookPayload

  "Delete an accounting book"
  deleteAccountingBook(
    "Accounting book ID to delete"
    id: ID!
  ): DeleteAccountingBookPayload

  "Create a new accounting presentation"
  createAccountingPresentation(
    "Presentation data"
    input: CreateAccountingPresentationInput!
  ): CreateAccountingPresentationPayload

  "Update an existing accounting presentation"
  updateAccountingPresentation(
    "Accounting presentation ID to update"
    id: ID!

    "Data to update"
    data: UpdateAccountingPresentationInput!
  ): UpdateAccountingPresentationPayload

  "Delete an accounting presentation"
  deleteAccountingPresentation(
    "Accounting presentation ID to delete"
    id: ID!
  ): DeleteAccountingPresentationPayload

  "Add a book to an accounting presentation"
  addBookToPresentation(
    "Presentation ID"
    presentationId: ID!

    "Accounting book ID"
    bookId: ID!
  ): UpdateAccountingPresentationPayload

  "Remove a book from an accounting presentation"
  removeBookFromPresentation(
    "Presentation ID"
    presentationId: ID!

    "Accounting book ID"
    bookId: ID!
  ): UpdateAccountingPresentationPayload

  "Create a new accounting entity"
  createAccountingEntity(input: CreateAccountingEntityInput!): CreateAccountingEntityPayload

  "Update an existing accounting entity"
  updateAccountingEntity(
    "Accounting entity ID to update"
    id: ID!

    "Data to update"
    data: UpdateAccountingEntityInput!
  ): UpdateAccountingEntityPayload

  "Delete an accounting entity"
  deleteAccountingEntity(
    "Accounting entity ID to delete"
    id: ID!
  ): DeleteAccountingEntityPayload

  "Crear comprobante contable con lneas en una sola transaccin"
  createAccountingEntryWithLines(input: CreateAccountingEntryWithLinesInput!): CreateAccountingEntryWithLinesPayload

  "Crear borrador de comprobante contable (solo encabezado)"
  createAccountingEntryDraft(input: CreateAccountingEntryDraftInput!): CreateAccountingEntryDraftPayload

  "Finalizar un borrador de comprobante contable y eliminar el borrador"
  finalizeAccountingEntryDraft(input: FinalizeAccountingEntryDraftInput!): FinalizeAccountingEntryDraftPayload

  "Eliminar lneas especficas de un borrador de comprobante contable"
  deleteDraftLines(input: DeleteDraftLinesInput!): DeleteDraftLinesPayload

  "Eliminar todas las lneas de un borrador de comprobante contable"
  clearDraftLines(input: ClearDraftLinesInput!): ClearDraftLinesPayload

  "Actualizar campos del encabezado de un borrador"
  updateDraft(input: UpdateDraftInput!): UpdateDraftPayload

  "Actualizar una lnea especfica de un borrador"
  updateDraftLine(input: UpdateDraftLineInput!): UpdateDraftLinePayload

  "Insertar nuevas lneas y\/o actualizar lneas existentes en un borrador"
  upsertDraftLines(input: UpsertDraftLinesInput!): UpsertDraftLinesPayload

  "Create a new book tax type"
  createTaxCategory(input: CreateTaxCategoryInput!): CreateTaxCategoryPayload

  "Update an existing book tax type"
  updateTaxCategory(id: ID!, data: UpdateTaxCategoryInput!): UpdateTaxCategoryPayload

  "Delete a book tax type"
  deleteTaxCategory(id: ID!): DeleteTaxCategoryPayload

  "Create a new tax"
  createTax(input: CreateTaxInput!): CreateTaxPayload

  "Update an existing tax"
  updateTax(id: ID!, data: UpdateTaxInput!): UpdateTaxPayload

  "Delete a tax"
  deleteTax(id: ID!): DeleteTaxPayload

  "Create a new accounting group"
  createAccountingGroup(input: CreateAccountingGroupInput!): CreateAccountingGroupPayload

  "Update an existing accounting group"
  updateAccountingGroup(id: ID!, data: UpdateAccountingGroupInput!): UpdateAccountingGroupPayload

  "Delete an accounting group"
  deleteAccountingGroup(id: ID!): DeleteAccountingGroupPayload

  "Create a new accounting account group"
  createAccountingAccountGroup(input: CreateAccountingAccountGroupInput!): CreateAccountingAccountGroupPayload

  "Create a new accounting account group with accounts (composite operation)"
  createAccountingAccountGroupWithAccounts(input: CreateAccountingAccountGroupWithAccountsInput!): CreateAccountingAccountGroupPayload

  "Update an existing accounting account group"
  updateAccountingAccountGroup(id: ID!, data: UpdateAccountingAccountGroupInput!): UpdateAccountingAccountGroupPayload

  "Update an existing accounting account group and sync its accounts (composite operation)"
  updateAccountingAccountGroupWithAccounts(id: ID!, data: UpdateAccountingAccountGroupWithAccountsInput!): UpdateAccountingAccountGroupPayload

  "Delete an accounting account group"
  deleteAccountingAccountGroup(id: ID!): DeleteAccountingAccountGroupPayload

  "Create a new payment method"
  createPaymentMethod(input: CreatePaymentMethodInput!): CreatePaymentMethodPayload

  "Update an existing payment method"
  updatePaymentMethod(
    "Payment method ID to update"
    id: ID!

    "Data to update"
    data: UpdatePaymentMethodInput!
  ): UpdatePaymentMethodPayload

  "Delete a payment method"
  deletePaymentMethod(
    "Payment method ID to delete"
    id: ID!
  ): DeletePaymentMethodPayload

  "Create a payment method from a bank account (auto-generates transfer PM)"
  createPaymentMethodForBankAccount(
    "Bank account ID to create transfer PM for"
    bankAccountId: ID!
  ): CreatePaymentMethodPayload

  "Create a new customer"
  createCustomer(input: CreateCustomerInput!): CreateCustomerPayload

  "Update an existing customer"
  updateCustomer(
    "Customer ID to update"
    id: ID!

    "Data to update"
    data: UpdateCustomerInput!
  ): UpdateCustomerPayload

  "Delete a customer"
  deleteCustomer(
    "Customer ID to delete"
    id: ID!
  ): DeleteCustomerPayload

  "Create a new seller"
  createSeller(input: CreateSellerInput!): CreateSellerPayload

  "Update an existing seller"
  updateSeller(
    "Seller ID to update"
    id: ID!

    "Data to update"
    data: UpdateSellerInput!
  ): UpdateSellerPayload

  "Delete a seller"
  deleteSeller(
    "Seller ID to delete"
    id: ID!
  ): DeleteSellerPayload

  "Create a new zone"
  createZone(input: CreateZoneInput!): CreateZonePayload

  "Update an existing zone"
  updateZone(
    "Zone ID to update"
    id: ID!

    "Data to update"
    data: UpdateZoneInput!
  ): UpdateZonePayload

  "Delete a zone"
  deleteZone(
    "Zone ID to delete"
    id: ID!
  ): DeleteZonePayload

  createInvoice(input: CreateInvoiceInput!): CreateInvoicePayload

  updateInvoice(id: ID!, data: UpdateInvoiceInput!): UpdateInvoicePayload

  deleteInvoice(id: ID!): DeleteInvoicePayload

  createAdditionalDiscountType(input: CreateAdditionalDiscountTypeInput!): CreateAdditionalDiscountTypePayload

  updateAdditionalDiscountType(id: ID!, data: UpdateAdditionalDiscountTypeInput!): UpdateAdditionalDiscountTypePayload

  deleteAdditionalDiscountType(id: ID!): DeleteAdditionalDiscountTypePayload

  "Create a new price list"
  createPriceList(input: CreatePriceListInput!): CreatePriceListPayload

  "Update an existing price list"
  updatePriceList(
    "Price list ID to update"
    id: ID!

    "Data to update"
    data: UpdatePriceListInput!
  ): UpdatePriceListPayload

  "Delete a price list"
  deletePriceList(
    "Price list ID to delete"
    id: ID!
  ): DeletePriceListPayload

  "Batch update prices for a price list (partial fields, upsert by item_id)"
  batchUpdatePriceListPrices(input: BatchUpdatePriceListPricesInput!): BatchUpdatePriceListPricesPayload

  "Create a new supplier"
  createSupplier(input: CreateSupplierInput!): CreateSupplierPayload

  "Update an existing supplier"
  updateSupplier(id: ID!, data: UpdateSupplierInput!): UpdateSupplierPayload

  "Delete a supplier"
  deleteSupplier(id: ID!): DeleteSupplierPayload

  "Create a new bank"
  createBank(input: CreateBankInput!): CreateBankPayload

  "Update an existing bank"
  updateBank(
    "Bank ID to update"
    id: ID!

    "Data to update"
    data: UpdateBankInput!
  ): UpdateBankPayload

  "Delete a bank"
  deleteBank(
    "Bank ID to delete"
    id: ID!
  ): DeleteBankPayload

  "Create a new bank account"
  createBankAccount(input: CreateBankAccountInput!): CreateBankAccountPayload

  "Update an existing bank account"
  updateBankAccount(
    "Bank account ID to update"
    id: ID!

    "Data to update"
    data: UpdateBankAccountInput!
  ): UpdateBankAccountPayload

  "Delete a bank account"
  deleteBankAccount(
    "Bank account ID to delete"
    id: ID!
  ): DeleteBankAccountPayload

  "Create a new cash drawer"
  createCashDrawer(input: CreateCashDrawerInput!): CreateCashDrawerPayload

  "Update an existing cash drawer"
  updateCashDrawer(
    "Cash drawer ID to update"
    id: ID!

    "Data to update"
    data: UpdateCashDrawerInput!
  ): UpdateCashDrawerPayload

  "Delete a cash drawer"
  deleteCashDrawer(
    "Cash drawer ID to delete"
    id: ID!
  ): DeleteCashDrawerPayload

  createFranchise(input: CreateFranchiseInput!): CreateFranchisePayload

  updateFranchise(
    "Franchise ID to update"
    id: ID!

    "Data to update"
    data: UpdateFranchiseInput!
  ): UpdateFranchisePayload

  deleteFranchise(
    "Franchise ID to delete"
    id: ID!
  ): DeleteFranchisePayload

  createFranchiseByCostCenter(input: CreateFranchiseByCostCenterInput!): CreateFranchiseByCostCenterPayload

  updateFranchiseByCostCenter(
    "Franchise by cost center ID to update"
    id: ID!

    "Data to update"
    data: UpdateFranchiseByCostCenterInput!
  ): UpdateFranchiseByCostCenterPayload

  deleteFranchiseByCostCenter(
    "Franchise by cost center ID to delete"
    id: ID!
  ): DeleteFranchiseByCostCenterPayload

  "Create a new concept"
  createTreasuryConcept(input: CreateTreasuryConceptInput!): CreateTreasuryConceptPayload

  "Update an existing concept"
  updateTreasuryConcept(
    "Concept ID to update"
    id: ID!

    "Data to update"
    data: UpdateTreasuryConceptInput!
  ): UpdateTreasuryConceptPayload

  "Delete a concept"
  deleteTreasuryConcept(
    "Concept ID to delete"
    id: ID!
  ): DeleteTreasuryConceptPayload

  createTreasuryConfig(input: CreateTreasuryConfigInput!): CreateTreasuryConfigPayload

  updateTreasuryConfig(data: UpdateTreasuryConfigInput!): UpdateTreasuryConfigPayload

  "Create a new measurement unit"
  createMeasurementUnit(input: CreateMeasurementUnitInput!): CreateMeasurementUnitPayload

  "Update an existing measurement unit"
  updateMeasurementUnit(id: ID!, data: UpdateMeasurementUnitInput!): UpdateMeasurementUnitPayload

  "Delete a measurement unit"
  deleteMeasurementUnit(id: ID!): DeleteMeasurementUnitPayload

  "Create a new item type"
  createItemType(input: CreateItemTypeInput!): CreateItemTypePayload

  "Update an existing item type"
  updateItemType(id: ID!, data: UpdateItemTypeInput!): UpdateItemTypePayload

  "Delete an item type"
  deleteItemType(id: ID!): DeleteItemTypePayload

  "Create a new image entry for an item"
  createImageByItem(input: CreateImageByItemInput!): CreateImageByItemPayload

  "Update an image entry (display_order only)"
  updateImageByItem(
    itemId: ID!, s3Bucket: String!, s3BucketDirectory: String!, s3FileName: String!, data: UpdateImageByItemInput!
  ): UpdateImageByItemPayload

  "Delete an image entry for an item"
  deleteImageByItem(itemId: ID!, s3Bucket: String!, s3BucketDirectory: String!, s3FileName: String!): DeleteImageByItemPayload

  "Create a new components_by_item relation"
  createComponentsByItem(input: CreateComponentsByItemInput!): CreateComponentsByItemPayload

  "Update an existing components_by_item relation (quantity only)"
  updateComponentsByItem(parentItemId: ID!, itemId: ID!, data: UpdateComponentsByItemInput!): UpdateComponentsByItemPayload

  "Delete a components_by_item relation"
  deleteComponentsByItem(parentItemId: ID!, itemId: ID!): DeleteComponentsByItemPayload

  "Create a new item category"
  createItemCategory(input: CreateItemCategoryInput!): CreateItemCategoryPayload

  "Update an existing item category"
  updateItemCategory(id: ID!, data: UpdateItemCategoryInput!): UpdateItemCategoryPayload

  "Delete an item category"
  deleteItemCategory(id: ID!): DeleteItemCategoryPayload

  "Create a new item sub category"
  createItemSubCategory(input: CreateItemSubCategoryInput!): CreateItemSubCategoryPayload

  "Update an existing item sub category"
  updateItemSubCategory(id: ID!, data: UpdateItemSubCategoryInput!): UpdateItemSubCategoryPayload

  "Delete an item sub category"
  deleteItemSubCategory(id: ID!): DeleteItemSubCategoryPayload

  "Create a new item brand"
  createItemBrand(input: CreateItemBrandInput!): CreateItemBrandPayload

  "Update an existing item brand"
  updateItemBrand(id: ID!, data: UpdateItemBrandInput!): UpdateItemBrandPayload

  "Delete an item brand"
  deleteItemBrand(id: ID!): DeleteItemBrandPayload

  "Create a new item size category"
  createItemSizeCategory(input: CreateItemSizeCategoryInput!): CreateItemSizeCategoryPayload

  "Update an existing item size category"
  updateItemSizeCategory(id: ID!, data: UpdateItemSizeCategoryInput!): UpdateItemSizeCategoryPayload

  "Delete an item size category"
  deleteItemSizeCategory(id: ID!): DeleteItemSizeCategoryPayload

  "Create a new item size value"
  createItemSizeValue(input: CreateItemSizeValueInput!): CreateItemSizeValuePayload

  "Update an existing item size value"
  updateItemSizeValue(id: ID!, data: UpdateItemSizeValueInput!): UpdateItemSizeValuePayload

  "Delete an item size value"
  deleteItemSizeValue(id: ID!): DeleteItemSizeValuePayload

  "Create a new item"
  createItem(input: CreateItemInput!): CreateItemPayload

  "Update an existing item"
  updateItem(id: ID!, data: UpdateItemInput!): UpdateItemPayload

  "Delete an item"
  deleteItem(id: ID!): DeleteItemPayload

  "Create a new lot"
  createLot(input: CreateLotInput!): CreateLotPayload

  "Update an existing lot"
  updateLot(id: ID!, data: UpdateLotInput!): UpdateLotPayload

  "Delete a lot"
  deleteLot(id: ID!): DeleteLotPayload

  "Create a document sequence"
  createDocumentSequence(input: CreateDocumentSequenceInput!): CreateDocumentSequencePayload

  "Update a document sequence"
  updateDocumentSequence(id: ID!, data: UpdateDocumentSequenceInput!): UpdateDocumentSequencePayload

  "Delete a document sequence"
  deleteDocumentSequence(id: ID!): DeleteDocumentSequencePayload

  "Create a document sequence monthly"
  createDocumentSequenceMonthly(input: CreateDocumentSequenceMonthlyInput!): CreateDocumentSequenceMonthlyPayload

  "Update a document sequence monthly"
  updateDocumentSequenceMonthly(id: ID!, data: UpdateDocumentSequenceMonthlyInput!): UpdateDocumentSequenceMonthlyPayload

  "Delete a document sequence monthly"
  deleteDocumentSequenceMonthly(id: ID!): DeleteDocumentSequenceMonthlyPayload

  "Create an authorization sequence type"
  createAuthorizationSequenceType(input: CreateAuthorizationSequenceTypeInput!): CreateAuthorizationSequenceTypePayload

  "Update an authorization sequence type"
  updateAuthorizationSequenceType(id: ID!, input: UpdateAuthorizationSequenceTypeInput!): UpdateAuthorizationSequenceTypePayload

  "Delete an authorization sequence type"
  deleteAuthorizationSequenceType(id: ID!): DeleteAuthorizationSequenceTypePayload

  "Create an authorization sequence"
  createAuthorizationSequence(input: CreateAuthorizationSequenceInput!): CreateAuthorizationSequencePayload

  "Update an authorization sequence"
  updateAuthorizationSequence(id: ID!, data: UpdateAuthorizationSequenceInput!): UpdateAuthorizationSequencePayload

  "Delete an authorization sequence"
  deleteAuthorizationSequence(id: ID!): DeleteAuthorizationSequencePayload

  "Create a new catalog"
  createCatalog(input: CreateCatalogInput!): CreateCatalogPayload

  "Update an existing catalog"
  updateCatalog(id: ID!, data: UpdateCatalogInput!): UpdateCatalogPayload

  "Delete a catalog"
  deleteCatalog(id: ID!): DeleteCatalogPayload

  "Create a new withholding certificate"
  createWithholdingCertificate(input: CreateWithholdingCertificateInput!): CreateWithholdingCertificatePayload

  "Update a withholding certificate"
  updateWithholdingCertificate(id: ID!, data: UpdateWithholdingCertificateInput!): UpdateWithholdingCertificatePayload

  "Delete a withholding certificate"
  deleteWithholdingCertificate(id: ID!): DeleteWithholdingCertificatePayload

  "Attach an accounting account to a withholding certificate"
  attachAccountToWithholdingCertificate(withholdingCertificateId: ID!, accountingAccountId: ID!): AttachAccountToWithholdingCertificatePayload

  "Detach an accounting account from a withholding certificate"
  detachAccountFromWithholdingCertificate(withholdingCertificateId: ID!, accountingAccountId: ID!): DetachAccountFromWithholdingCertificatePayload

  "Create a new withholding type"
  createWithholdingType(input: CreateWithholdingTypeInput!): CreateWithholdingTypePayload

  "Update an existing withholding type"
  updateWithholdingType(id: ID!, data: UpdateWithholdingTypeInput!): UpdateWithholdingTypePayload

  "Delete a withholding type"
  deleteWithholdingType(id: ID!): DeleteWithholdingTypePayload

  "Create an SMTP server"
  createSmtp(input: CreateSmtpInput!): CreateSmtpPayload

  "Update an SMTP server"
  updateSmtp(id: ID!, data: UpdateSmtpInput!): UpdateSmtpPayload

  "Delete an SMTP server"
  deleteSmtp(id: ID!): DeleteSmtpPayload

  "Create a new email"
  createEmail(
    "Email data"
    input: CreateEmailInput!
  ): CreateEmailPayload

  "Update an existing email"
  updateEmail(
    "Email ID to update"
    id: ID!

    "Data to update"
    data: UpdateEmailInput!
  ): UpdateEmailPayload

  "Delete an email"
  deleteEmail(
    "Email ID to delete"
    id: ID!
  ): DeleteEmailPayload

  "Create a new AWS S3 config"
  createAwsS3Config(input: CreateAwsS3ConfigInput!): CreateAwsS3ConfigPayload

  "Update an existing AWS S3 config"
  updateAwsS3Config(id: ID!, data: UpdateAwsS3ConfigInput!): UpdateAwsS3ConfigPayload

  "Delete an AWS S3 config"
  deleteAwsS3Config(id: ID!): DeleteAwsS3ConfigPayload

  "Crea una configuracin DIAN"
  createDianSoftwareConfig(input: CreateDianSoftwareConfigInput!): CreateDianSoftwareConfigPayload

  "Actualiza una configuracin DIAN"
  updateDianSoftwareConfig(id: ID!, input: UpdateDianSoftwareConfigInput!): UpdateDianSoftwareConfigPayload

  "Elimina una configuracin DIAN"
  deleteDianSoftwareConfig(id: ID!): DeleteDianSoftwareConfigPayload

  "Activa una configuracin DIAN y desactiva otras del mismo entorno\/categora"
  activateDianSoftwareConfig(id: ID!): UpdateDianSoftwareConfigPayload

  "Crea un certificado DIAN"
  createDianCertificate(input: CreateDianCertificateInput!): CreateDianCertificatePayload

  "Actualiza un certificado DIAN"
  updateDianCertificate(id: ID!, input: UpdateDianCertificateInput!): UpdateDianCertificatePayload

  "Elimina un certificado DIAN"
  deleteDianCertificate(id: ID!): DeleteDianCertificatePayload

  "Create a new currency"
  createCurrency(
    "Currency data"
    input: CreateCurrencyInput!
  ): CreateCurrencyPayload

  "Update an existing currency"
  updateCurrency(
    "Currency ID to update"
    id: ID!

    "Data to update"
    data: UpdateCurrencyInput!
  ): UpdateCurrencyPayload

  "Delete a currency"
  deleteCurrency(
    "Currency ID to delete"
    id: ID!
  ): DeleteCurrencyPayload

  "Create a new building"
  createBuilding(input: CreateBuildingInput!): CreateBuildingPayload

  "Update an existing building"
  updateBuilding(id: ID!, data: UpdateBuildingInput!): UpdateBuildingPayload

  "Delete a building"
  deleteBuilding(id: ID!): DeleteBuildingPayload

  "Create a new tower"
  createTower(input: CreateTowerInput!): CreateTowerPayload

  "Update an existing tower"
  updateTower(id: ID!, data: UpdateTowerInput!): UpdateTowerPayload

  "Delete a tower"
  deleteTower(id: ID!): DeleteTowerPayload

  "Create a new floor"
  createFloor(input: CreateFloorInput!): CreateFloorPayload

  "Update an existing floor"
  updateFloor(id: ID!, data: UpdateFloorInput!): UpdateFloorPayload

  "Delete a floor"
  deleteFloor(id: ID!): DeleteFloorPayload

  "Create a new unit"
  createUnit(input: CreateUnitInput!): CreateUnitPayload

  "Update an existing unit"
  updateUnit(id: ID!, data: UpdateUnitInput!): UpdateUnitPayload

  "Delete a unit"
  deleteUnit(id: ID!): DeleteUnitPayload

  "Create a new unit billing schedule"
  createUnitBillingSchedule(input: CreateUnitBillingScheduleInput!): CreateUnitBillingSchedulePayload

  "Update an existing unit billing schedule"
  updateUnitBillingSchedule(id: ID!, data: UpdateUnitBillingScheduleInput!): UpdateUnitBillingSchedulePayload

  "Delete a unit billing schedule"
  deleteUnitBillingSchedule(id: ID!): DeleteUnitBillingSchedulePayload

  "Create a new unit billing schedule line"
  createUnitBillingScheduleLine(input: CreateUnitBillingScheduleLineInput!): CreateUnitBillingScheduleLinePayload

  "Update an existing unit billing schedule line"
  updateUnitBillingScheduleLine(id: ID!, data: UpdateUnitBillingScheduleLineInput!): UpdateUnitBillingScheduleLinePayload

  "Delete a unit billing schedule line"
  deleteUnitBillingScheduleLine(id: ID!): DeleteUnitBillingScheduleLinePayload

  "Create a new unit billing schedule line tax"
  createUnitBillingScheduleLineTax(input: CreateUnitBillingScheduleLineTaxInput!): CreateUnitBillingScheduleLineTaxPayload

  "Update an existing unit billing schedule line tax"
  updateUnitBillingScheduleLineTax(id: ID!, data: UpdateUnitBillingScheduleLineTaxInput!): UpdateUnitBillingScheduleLineTaxPayload

  "Delete a unit billing schedule line tax"
  deleteUnitBillingScheduleLineTax(id: ID!): DeleteUnitBillingScheduleLineTaxPayload

  "Create a new unit billing schedule line discount"
  createUnitBillingScheduleLineDiscount(input: CreateUnitBillingScheduleLineDiscountInput!): CreateUnitBillingScheduleLineDiscountPayload

  "Update an existing unit billing schedule line discount"
  updateUnitBillingScheduleLineDiscount(id: ID!, data: UpdateUnitBillingScheduleLineDiscountInput!): UpdateUnitBillingScheduleLineDiscountPayload

  "Delete a unit billing schedule line discount"
  deleteUnitBillingScheduleLineDiscount(id: ID!): DeleteUnitBillingScheduleLineDiscountPayload
}

type UnitBillingSchedule {
  id: ID
  unit: Unit
  priceList: PriceList
  observationTemplate: String
  company: Company
  createdBy: Account
  lines: [UnitBillingScheduleLine]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type UnitBillingScheduleLine {
  id: ID
  schedule: UnitBillingSchedule
  item: Item
  billedEntity: AccountingEntity
  quantity: Decimal
  price: Decimal
  listPrice: Decimal
  isAiu: Boolean
  aiuAdministrationRate: Decimal
  aiuUnforeseenRate: Decimal
  aiuProfitRate: Decimal
  displayOrder: Int
  company: Company
  createdBy: Account
  taxes: [UnitBillingScheduleLineTax]
  discounts: [UnitBillingScheduleLineDiscount]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type UnitBillingScheduleLineTax {
  id: ID
  line: UnitBillingScheduleLine
  tax: Tax
  taxName: String
  taxRate: Decimal
  company: Company
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type UnitBillingScheduleLineDiscount {
  id: ID
  line: UnitBillingScheduleLine
  discountType: AdditionalDiscountType
  discountSource: String
  discountName: String
  discountRate: Decimal
  discountOrder: Int
  company: Company
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type UnitBillingSchedulePage {
  entries: [UnitBillingSchedule]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

type UnitBillingScheduleLinePage {
  entries: [UnitBillingScheduleLine]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

type UnitBillingScheduleLineTaxPage {
  entries: [UnitBillingScheduleLineTax]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

type UnitBillingScheduleLineDiscountPage {
  entries: [UnitBillingScheduleLineDiscount]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

input UnitBillingScheduleFilters {
  unitId: Int
  priceListId: Int
  text: String
}

input UnitBillingScheduleLineFilters {
  unitBillingScheduleId: Int!
  itemId: Int
  billedEntityId: Int
  isAiu: Boolean
  displayOrderFrom: Int
  displayOrderTo: Int
  text: String
}

input UnitBillingScheduleLineTaxFilters {
  unitBillingScheduleLineId: Int!
  taxId: Int
  text: String
}

input UnitBillingScheduleLineDiscountFilters {
  unitBillingScheduleLineId: Int!
  discountTypeId: Int
  discountOrder: Int
  text: String
}

input CreateUnitBillingScheduleInput {
  unitId: ID!
  priceListId: ID!
  observationTemplate: String
  createdById: ID!
}

input UpdateUnitBillingScheduleInput {
  unitId: ID
  priceListId: ID
  observationTemplate: String
}

input CreateUnitBillingScheduleLineInput {
  unitBillingScheduleId: ID!
  itemId: ID!
  billedEntityId: ID!
  quantity: Decimal!
  price: Decimal!
  listPrice: Decimal!
  isAiu: Boolean
  aiuAdministrationRate: Decimal
  aiuUnforeseenRate: Decimal
  aiuProfitRate: Decimal
  displayOrder: Int
  createdById: ID!
}

input UpdateUnitBillingScheduleLineInput {
  unitBillingScheduleId: ID
  itemId: ID
  billedEntityId: ID
  quantity: Decimal
  price: Decimal
  listPrice: Decimal
  isAiu: Boolean
  aiuAdministrationRate: Decimal
  aiuUnforeseenRate: Decimal
  aiuProfitRate: Decimal
  displayOrder: Int
}

input CreateUnitBillingScheduleLineTaxInput {
  unitBillingScheduleLineId: ID!
  taxId: ID!
  taxName: String!
  taxRate: Decimal!
}

input UpdateUnitBillingScheduleLineTaxInput {
  taxId: ID
  taxName: String
  taxRate: Decimal
}

input CreateUnitBillingScheduleLineDiscountInput {
  unitBillingScheduleLineId: ID!
  discountTypeId: ID
  discountSource: String
  discountName: String!
  discountRate: Decimal!
  discountOrder: Int!
}

input UpdateUnitBillingScheduleLineDiscountInput {
  discountTypeId: ID
  discountSource: String
  discountName: String
  discountRate: Decimal
  discountOrder: Int
}

type CreateUnitBillingSchedulePayload {
  unitBillingSchedule: UnitBillingSchedule
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateUnitBillingSchedulePayload {
  unitBillingSchedule: UnitBillingSchedule
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteUnitBillingSchedulePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

type CreateUnitBillingScheduleLinePayload {
  unitBillingScheduleLine: UnitBillingScheduleLine
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateUnitBillingScheduleLinePayload {
  unitBillingScheduleLine: UnitBillingScheduleLine
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteUnitBillingScheduleLinePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

type CreateUnitBillingScheduleLineTaxPayload {
  unitBillingScheduleLineTax: UnitBillingScheduleLineTax
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateUnitBillingScheduleLineTaxPayload {
  unitBillingScheduleLineTax: UnitBillingScheduleLineTax
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteUnitBillingScheduleLineTaxPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

type CreateUnitBillingScheduleLineDiscountPayload {
  unitBillingScheduleLineDiscount: UnitBillingScheduleLineDiscount
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateUnitBillingScheduleLineDiscountPayload {
  unitBillingScheduleLineDiscount: UnitBillingScheduleLineDiscount
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteUnitBillingScheduleLineDiscountPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

enum UnitStatus {
  ACTIVE
  INACTIVE
}

type Unit {
  id: ID
  name: String
  status: UnitStatus
  floor: Floor
  ownerEntity: AccountingEntity
  tenantEntity: AccountingEntity
  company: Company
  createdBy: Account
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type UnitPage {
  entries: [Unit]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

input UnitFilters {
  name: String
  floorId: Int
  ownerEntityId: Int
  tenantEntityId: Int
  status: UnitStatus
}

enum UnitSortField {
  ID
  NAME
  STATUS
  FLOOR_ID
  COMPANY_ID
  INSERTED_AT
  UPDATED_AT
}

input UnitSortInput {
  field: UnitSortField!
  direction: SortDirection!
}

input CreateUnitInput {
  name: String!
  status: UnitStatus
  floorId: ID!
  ownerEntityId: ID!
  tenantEntityId: ID
}

input UpdateUnitInput {
  name: String
  status: UnitStatus
  floorId: ID
  ownerEntityId: ID
  tenantEntityId: ID
}

type CreateUnitPayload {
  unit: Unit
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateUnitPayload {
  unit: Unit
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteUnitPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete unit"
type CanDeleteUnitPayload {
  "Whether the unit can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for unit"
type UnitChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a unit"
type UnitTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [UnitChange]!
}

"Filters for Unit timeline"
input UnitTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Unit timeline"
enum UnitTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Unit timeline"
input UnitTimelineSortInput {
  "Field to sort by"
  field: UnitTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Unit timeline"
type UnitTimelinePage {
  "Timeline items for current page"
  entries: [UnitTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

type Floor {
  id: ID
  name: String
  tower: Tower
  company: Company
  createdBy: Account
  units: [Unit]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type FloorPage {
  entries: [Floor]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

input FloorFilters {
  name: String
  towerId: Int
}

enum FloorSortField {
  ID
  NAME
  TOWER_ID
  COMPANY_ID
  INSERTED_AT
  UPDATED_AT
}

input FloorSortInput {
  field: FloorSortField!
  direction: SortDirection!
}

input CreateFloorInput {
  name: String!
  towerId: ID!
}

input UpdateFloorInput {
  name: String
  towerId: ID
}

type CreateFloorPayload {
  floor: Floor
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateFloorPayload {
  floor: Floor
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteFloorPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete floor"
type CanDeleteFloorPayload {
  "Whether the floor can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for floor"
type FloorChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a floor"
type FloorTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [FloorChange]!
}

"Filters for Floor timeline"
input FloorTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Floor timeline"
enum FloorTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Floor timeline"
input FloorTimelineSortInput {
  "Field to sort by"
  field: FloorTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Floor timeline"
type FloorTimelinePage {
  "Timeline items for current page"
  entries: [FloorTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

type Tower {
  id: ID
  name: String
  building: Building
  company: Company
  createdBy: Account
  floors: [Floor]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type TowerPage {
  entries: [Tower]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

input TowerFilters {
  name: String
  buildingId: Int
}

enum TowerSortField {
  ID
  NAME
  BUILDING_ID
  COMPANY_ID
  INSERTED_AT
  UPDATED_AT
}

input TowerSortInput {
  field: TowerSortField!
  direction: SortDirection!
}

input CreateTowerInput {
  name: String!
  buildingId: ID!
}

input UpdateTowerInput {
  name: String
  buildingId: ID
}

type CreateTowerPayload {
  tower: Tower
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateTowerPayload {
  tower: Tower
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteTowerPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete tower"
type CanDeleteTowerPayload {
  "Whether the tower can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for tower"
type TowerChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a tower"
type TowerTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [TowerChange]!
}

"Filters for Tower timeline"
input TowerTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Tower timeline"
enum TowerTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Tower timeline"
input TowerTimelineSortInput {
  "Field to sort by"
  field: TowerTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Tower timeline"
type TowerTimelinePage {
  "Timeline items for current page"
  entries: [TowerTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

type Building {
  id: ID
  name: String
  address: String
  city: City
  costCenter: CostCenter
  company: Company
  createdBy: Account
  towers: [Tower]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

type BuildingPage {
  entries: [Building]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

input BuildingFilters {
  name: String
  cityId: Int
  costCenterId: Int
}

enum BuildingSortField {
  ID
  NAME
  ADDRESS
  CITY_ID
  COST_CENTER_ID
  COMPANY_ID
  INSERTED_AT
  UPDATED_AT
}

input BuildingSortInput {
  field: BuildingSortField!
  direction: SortDirection!
}

input CreateBuildingInput {
  name: String!
  address: String
  cityId: ID!
  costCenterId: ID!
}

input UpdateBuildingInput {
  name: String
  address: String
  cityId: ID
  costCenterId: ID
}

type CreateBuildingPayload {
  building: Building
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateBuildingPayload {
  building: Building
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteBuildingPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete building"
type CanDeleteBuildingPayload {
  "Whether the building can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for building"
type BuildingChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a building"
type BuildingTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [BuildingChange]!
}

"Filters for Building timeline"
input BuildingTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Building timeline"
enum BuildingTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Building timeline"
input BuildingTimelineSortInput {
  "Field to sort by"
  field: BuildingTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Building timeline"
type BuildingTimelinePage {
  "Timeline items for current page"
  entries: [BuildingTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Max length metadata for a single string column"
type StringFieldLength {
  column: String!
  maxLength: Int!
}

"String field lengths for a single entity\/table"
type EntityStringLengths {
  entity: String!
  domain: String!
  displayName: String!
  schema: String!
  table: String!
  fields: [StringFieldLength!]!
}

"Repository configuration information"
type RepoConfig {
  "Database server hostname"
  hostname: String

  "Database username"
  username: String

  "Database name"
  database: String

  "Connection port"
  port: Int

  "Connection timeout in ms"
  timeout: Int

  "Connection pool size"
  poolSize: Int
}

"Complete dynamic repository information"
type Repository {
  "Unique repository name"
  name: String!

  "Generated Elixir module name"
  moduleName: String!

  "Repository process ID"
  pid: String

  "Current repository status"
  status: RepoStatus!

  "Creation date and time"
  createdAt: IsoDatetime

  "Connection configuration"
  config: RepoConfig

  "Number of active connections"
  connectionCount: Int

  "Whether the process is alive"
  isAlive: Boolean!
}

"Repository status"
enum RepoStatus {
  "Repository is active and running"
  ACTIVE

  "Repository created but inactive"
  INACTIVE

  "Repository with errors"
  ERROR

  "Unknown status"
  UNKNOWN
}

"General repository statistics"
type RepoStats {
  "Total registered repositories"
  totalRepos: Int!

  "Active repositories"
  activeRepos: Int!

  "Inactive repositories"
  inactiveRepos: Int!

  "Maximum repository limit"
  maxRepos: Int!

  "Available slots"
  availableSlots: Int!

  "Estimated total database connections"
  totalConnections: Int
}

"Paginated repository response"
type RepoConnection {
  "List of repositories"
  repos: [Repository!]!

  "Total repository count"
  totalCount: Int!

  "Whether there are more pages"
  hasNextPage: Boolean!

  "Whether there are previous pages"
  hasPreviousPage: Boolean!
}

"Filters for searching repositories"
input RepoFilters {
  "Filter by status"
  status: RepoStatus

  "Filter by database name"
  databaseName: String

  "Filter by hostname"
  hostname: String

  "Search by name (partial match)"
  search: String
}

"Input for repo\/server cache invalidation"
input InvalidateRepoConfigInput {
  "Target database identifier"
  databaseId: ID!
}

"Response for repo\/server cache invalidation"
type InvalidateRepoConfigPayload {
  success: Boolean!
  message: String
}

"DIAN Certificate entity"
type DianCertificate {
  id: ID
  certificatePem: String
  privateKeyPem: String
  serialNumber: String
  issuer: String
  subject: String
  validFrom: IsoDatetime
  validTo: IsoDatetime
  isActive: Boolean
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
  company: Company
}

"Input para crear certificado DIAN"
input CreateDianCertificateInput {
  certificatePem: String!
  privateKeyPem: String!
  validFrom: IsoDatetime!
  validTo: IsoDatetime!
  serialNumber: String
  issuer: String
  subject: String
  isActive: Boolean
}

"Input para actualizar certificado DIAN"
input UpdateDianCertificateInput {
  certificatePem: String
  privateKeyPem: String
  validFrom: IsoDatetime
  validTo: IsoDatetime
  serialNumber: String
  issuer: String
  subject: String
  isActive: Boolean
}

type CreateDianCertificatePayload {
  success: Boolean!
  message: String
  errors: [FieldError]
  certificate: DianCertificate
}

type UpdateDianCertificatePayload {
  success: Boolean!
  message: String
  errors: [FieldError]
  certificate: DianCertificate
}

type DeleteDianCertificatePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"DIAN environment"
enum DianEnvironment {
  "Entorno de habilitacin (sandbox)"
  SANDBOX

  "Entorno de produccin"
  PRODUCTION
}

"DIAN document category"
enum DianDocumentCategory {
  "Facturacin electrnica (FE)"
  INVOICE

  "Nmina electrnica (NE)"
  PAYROLL

  "Documento soporte (DS)"
  SUPPORT_DOCUMENT
}

"DIAN Software Configuration entity"
type DianSoftwareConfig {
  "Identificador nico"
  id: ID

  "Entorno DIAN"
  environment: DianEnvironment

  "Categora de documento"
  documentCategory: DianDocumentCategory

  "NIT del proveedor tecnolgico"
  providerNit: String

  "DV del proveedor tecnolgico"
  providerDv: String

  "ID del software registrado ante DIAN"
  softwareId: String

  "PIN del software DIAN"
  softwarePin: String

  "ID del set de pruebas (habilitacin)"
  testSetId: String

  "URL del servicio DIAN"
  serviceUrl: String

  "URL del WSDL del servicio DIAN"
  wsdlUrl: String

  "Configuracin activa"
  isActive: Boolean

  "Fecha de creacin"
  insertedAt: IsoDatetime

  "Fecha de actualizacin"
  updatedAt: IsoDatetime

  "Empresa duea de la configuracin"
  company: Company
}

"Input para crear configuracin DIAN"
input CreateDianSoftwareConfigInput {
  environment: DianEnvironment!
  documentCategory: DianDocumentCategory!
  providerNit: String!
  providerDv: String!
  softwareId: String!
  softwarePin: String!
  testSetId: String
  serviceUrl: String!
  wsdlUrl: String!
  isActive: Boolean
}

"Input para actualizar configuracin DIAN"
input UpdateDianSoftwareConfigInput {
  providerNit: String
  providerDv: String
  softwareId: String
  softwarePin: String
  testSetId: String
  serviceUrl: String
  wsdlUrl: String
  isActive: Boolean
}

"Payload de creacin de configuracin DIAN"
type CreateDianSoftwareConfigPayload {
  success: Boolean!
  message: String
  errors: [FieldError]
  config: DianSoftwareConfig
}

"Payload de actualizacin de configuracin DIAN"
type UpdateDianSoftwareConfigPayload {
  success: Boolean!
  message: String
  errors: [FieldError]
  config: DianSoftwareConfig
}

"Payload de eliminacin de configuracin DIAN"
type DeleteDianSoftwareConfigPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Lot entity"
type Lot {
  "Unique lot identifier"
  id: ID

  "Lot number"
  lotNumber: String!

  "Expiration date"
  expirationDate: Date

  "Company this lot belongs to"
  company: Company

  "Item this lot belongs to"
  item: Item

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated lot response"
type LotPage {
  "List of lots for current page"
  entries: [Lot]!

  "Total matching lots"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching lots"
input LotFilters {
  "Filter by lot number (partial match)"
  lotNumber: String

  "Filter by item ID"
  itemId: Int

  "Filter by expiration date from (inclusive)"
  expirationFrom: Date

  "Filter by expiration date to (inclusive)"
  expirationTo: Date
}

"Available fields for sorting lots"
enum LotSortField {
  "Sort by lot ID"
  ID

  "Sort by lot number"
  LOT_NUMBER

  "Sort by expiration date"
  EXPIRATION_DATE

  "Sort by item ID"
  ITEM_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for lots"
input LotSortInput {
  "Field to sort by"
  field: LotSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create lot input"
input CreateLotInput {
  "Lot number"
  lotNumber: String!

  "Item ID"
  itemId: Int!

  "Expiration date"
  expirationDate: Date
}

"Update lot data"
input UpdateLotInput {
  "Lot number"
  lotNumber: String

  "Expiration date"
  expirationDate: Date
}

"Lot creation response"
type CreateLotPayload {
  "Created lot"
  lot: Lot

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Lot update response"
type UpdateLotPayload {
  "Updated lot"
  lot: Lot

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Lot deletion response"
type DeleteLotPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted lot ID"
  deletedId: ID
}

"Response for can delete lot"
type CanDeleteLotPayload {
  "Whether the lot can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Image registered for an item"
type ImageByItem {
  "Item owning the image"
  item: Item

  s3Bucket: String

  s3BucketDirectory: String

  s3FileName: String

  displayOrder: Int
}

"Create image_by_item input"
input CreateImageByItemInput {
  itemId: ID!
  s3Bucket: String!
  s3BucketDirectory: String!
  s3FileName: String!
  displayOrder: Int
}

"Update image_by_item input"
input UpdateImageByItemInput {
  displayOrder: Int!
}

"Create image_by_item payload"
type CreateImageByItemPayload {
  imageByItem: ImageByItem
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Update image_by_item payload"
type UpdateImageByItemPayload {
  imageByItem: ImageByItem
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Delete image_by_item payload"
type DeleteImageByItemPayload {
  success: Boolean!
  message: String
  deletedIds: [ID]
}

"ComponentsByItem relation entry (parent -> component)"
type ComponentsByItem {
  "Parent item"
  parent: Item

  "Component (child) item"
  component: Item

  "Quantity of component in parent composition"
  quantity: Decimal
}

"Create components_by_item input"
input CreateComponentsByItemInput {
  parentItemId: ID!
  itemId: ID!
  quantity: Decimal!
}

"Update components_by_item input"
input UpdateComponentsByItemInput {
  quantity: Decimal!
}

"Create components_by_item payload"
type CreateComponentsByItemPayload {
  componentsByItem: ComponentsByItem
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Update components_by_item payload"
type UpdateComponentsByItemPayload {
  componentsByItem: ComponentsByItem
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Delete components_by_item payload"
type DeleteComponentsByItemPayload {
  success: Boolean!
  message: String
  deletedIds: [ID]
}

"Item entity"
type Item {
  "Unique item identifier"
  id: ID

  "Item name"
  name: String

  "Dynamic name template with placeholders resolved at billing time"
  nameTemplate: String

  "Item reference"
  reference: String

  "Business code"
  code: String

  "Active status"
  isActive: Boolean

  "Allows fractional quantities"
  allowFraction: Boolean

  "Has extended information"
  hasExtendedInformation: Boolean

  "AIU-based service"
  aiuBasedService: Boolean

  "Billable item"
  billable: Boolean

  "Amounts based on weight"
  amountBasedOnWeight: Boolean

  "Owning company"
  company: Company

  "Measurement unit"
  measurementUnit: MeasurementUnit

  "Brand"
  brand: ItemBrand

  "Size category"
  sizeCategory: ItemSizeCategory

  "Accounting group"
  accountingGroup: AccountingGroup

  "Sub category"
  subCategory: ItemSubCategory

  "Receivable accounting account for this item"
  receivableAccount: AccountingAccount

  "Components (child item + quantity) for this parent item"
  components: [ComponentsByItem]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Item component input for updating components list"
input ItemComponentInput {
  itemId: ID!
  quantity: Decimal!
}

"Item image input for creating\/updating item images"
input ItemImageInput {
  s3Bucket: String!
  s3BucketDirectory: String!
  s3FileName: String!
  displayOrder: Int
}

"Paginated item response"
type ItemPage {
  "List of items in current page"
  entries: [Item]!

  "Total number of items matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching items"
input ItemFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by name template (partial match)"
  nameTemplate: String

  "Filter by reference (partial match)"
  reference: String

  "Filter by code (partial match)"
  code: String

  "Filter by active status"
  isActive: Boolean

  "Filter by billable status"
  billable: Boolean

  "Filter by weight-based amount"
  amountBasedOnWeight: Boolean

  "Filter by AIU-based service"
  aiuBasedService: Boolean

  "Filter by measurement unit ID"
  measurementUnitId: Int

  "Filter by brand ID"
  brandId: Int

  "Filter by size category ID"
  sizeCategoryId: Int

  "Filter by accounting group ID"
  accountingGroupId: Int

  "Filter by sub category ID"
  subCategoryId: Int

  "Filter by receivable account ID"
  receivableAccountId: Int
}

"Available fields for sorting items"
enum ItemSortField {
  "Sort by item ID"
  ID

  "Sort by name"
  NAME

  "Sort by name template"
  NAME_TEMPLATE

  "Sort by reference"
  REFERENCE

  "Sort by code"
  CODE

  "Sort by active status"
  IS_ACTIVE

  "Sort by allow fraction flag"
  ALLOW_FRACTION

  "Sort by extended information flag"
  HAS_EXTENDED_INFORMATION

  "Sort by AIU-based service flag"
  AIU_BASED_SERVICE

  "Sort by billable flag"
  BILLABLE

  "Sort by weight-based amount flag"
  AMOUNT_BASED_ON_WEIGHT

  "Sort by measurement unit ID"
  MEASUREMENT_UNIT_ID

  "Sort by brand ID"
  BRAND_ID

  "Sort by size category ID"
  SIZE_CATEGORY_ID

  "Sort by accounting group ID"
  ACCOUNTING_GROUP_ID

  "Sort by sub category ID"
  SUB_CATEGORY_ID

  "Sort by receivable account ID"
  RECEIVABLE_ACCOUNT_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for items"
input ItemSortInput {
  "Field to sort by"
  field: ItemSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item input"
input CreateItemInput {
  name: String!

  "Dynamic name template with placeholders"
  nameTemplate: String

  reference: String!

  isActive: Boolean

  allowFraction: Boolean

  hasExtendedInformation: Boolean

  measurementUnitId: ID!

  aiuBasedService: Boolean

  brandId: ID

  sizeCategoryId: ID

  accountingGroupId: ID!

  subCategoryId: ID!

  "Receivable account ID"
  receivableAccountId: ID

  billable: Boolean

  amountBasedOnWeight: Boolean

  eanCodes: [String]

  images: [ItemImageInput]

  components: [ItemComponentInput]
}

"Update item input"
input UpdateItemInput {
  name: String

  "Dynamic name template with placeholders"
  nameTemplate: String

  reference: String

  isActive: Boolean

  allowFraction: Boolean

  hasExtendedInformation: Boolean

  measurementUnitId: ID

  aiuBasedService: Boolean

  brandId: ID

  sizeCategoryId: ID

  accountingGroupId: ID

  subCategoryId: ID

  "Receivable account ID"
  receivableAccountId: ID

  billable: Boolean

  amountBasedOnWeight: Boolean

  components: [ItemComponentInput]

  eanCodes: [String]

  images: [ItemImageInput]
}

"Item creation response"
type CreateItemPayload {
  item: Item
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Item update response"
type UpdateItemPayload {
  item: Item
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Item deletion response"
type DeleteItemPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete item"
type CanDeleteItemPayload {
  canDelete: Boolean!
  message: String
}

"Humanized field-level change"
type ItemChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an item"
type ItemTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemChange]!
}

"Filters for Item timeline"
input ItemTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Item timeline"
enum ItemTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Item timeline"
input ItemTimelineSortInput {
  "Field to sort by"
  field: ItemTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Item timeline"
type ItemTimelinePage {
  "Timeline items for current page"
  entries: [ItemTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Item Size Value entity"
type ItemSizeValue {
  "Unique item size value identifier"
  id: ID

  "Item size value name"
  name: String!

  "Display order within category"
  displayOrder: Int!

  "Company this item size value belongs to"
  company: Company

  "Item Size Category this value belongs to"
  itemSizeCategory: ItemSizeCategory

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated item size value response"
type ItemSizeValuePage {
  "List of item size values for current page"
  entries: [ItemSizeValue]!

  "Total number of item size values matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching item size values"
input ItemSizeValueFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by item size category ID"
  itemSizeCategoryId: Int

  "Filter by display order"
  displayOrder: Int
}

"Available fields for sorting item size values"
enum ItemSizeValueSortField {
  "Sort by item size value ID"
  ID

  "Sort by name"
  NAME

  "Sort by display order"
  DISPLAY_ORDER

  "Sort by category ID"
  ITEM_SIZE_CATEGORY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for item size values"
input ItemSizeValueSortInput {
  "Field to sort by"
  field: ItemSizeValueSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item size value input"
input CreateItemSizeValueInput {
  "Item size value name"
  name: String!

  "Display order within category"
  displayOrder: Int!

  "Item Size Category ID"
  itemSizeCategoryId: Int!
}

"Update item size value data"
input UpdateItemSizeValueInput {
  "Item size value name"
  name: String

  "Display order within category"
  displayOrder: Int
}

"Item size value creation response"
type CreateItemSizeValuePayload {
  "Created item size value"
  itemSizeValue: ItemSizeValue

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Item size value update response"
type UpdateItemSizeValuePayload {
  "Updated item size value"
  itemSizeValue: ItemSizeValue

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Item size value deletion response"
type DeleteItemSizeValuePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted item size value ID"
  deletedId: ID
}

"Response for can delete item size value"
type CanDeleteItemSizeValuePayload {
  "Whether the item size value can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type ItemSizeValueChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an item size value"
type ItemSizeValueTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemSizeValueChange]!
}

"Filters for ItemSizeValue timeline"
input ItemSizeValueTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ItemSizeValue timeline"
enum ItemSizeValueTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ItemSizeValue timeline"
input ItemSizeValueTimelineSortInput {
  "Field to sort by"
  field: ItemSizeValueTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ItemSizeValue timeline"
type ItemSizeValueTimelinePage {
  "Timeline items for current page"
  entries: [ItemSizeValueTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Item Size Category entity"
type ItemSizeCategory {
  "Unique item size category identifier"
  id: ID

  "Item size category name"
  name: String!

  "Company this item size category belongs to"
  company: Company

  "Item size values belonging to this category"
  itemSizeValues: [ItemSizeValue]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated item size category response"
type ItemSizeCategoryPage {
  "List of item size categories for current page"
  entries: [ItemSizeCategory]!

  "Total number of item size categories matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching item size categories"
input ItemSizeCategoryFilters {
  "Filter by name (partial match)"
  name: String
}

"Available fields for sorting item size categories"
enum ItemSizeCategorySortField {
  "Sort by item size category ID"
  ID

  "Sort by name"
  NAME

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for item size categories"
input ItemSizeCategorySortInput {
  "Field to sort by"
  field: ItemSizeCategorySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item size category input"
input CreateItemSizeCategoryInput {
  "Item size category name"
  name: String!
}

"Update item size category data"
input UpdateItemSizeCategoryInput {
  "Item size category name"
  name: String
}

"Item size category creation response"
type CreateItemSizeCategoryPayload {
  "Created item size category"
  itemSizeCategory: ItemSizeCategory

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Item size category update response"
type UpdateItemSizeCategoryPayload {
  "Updated item size category"
  itemSizeCategory: ItemSizeCategory

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Item size category deletion response"
type DeleteItemSizeCategoryPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted item size category ID"
  deletedId: ID
}

"Response for can delete item size category"
type CanDeleteItemSizeCategoryPayload {
  "Whether the item size category can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type ItemSizeCategoryChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an item size category"
type ItemSizeCategoryTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemSizeCategoryChange]!
}

"Filters for ItemSizeCategory timeline"
input ItemSizeCategoryTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ItemSizeCategory timeline"
enum ItemSizeCategoryTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ItemSizeCategory timeline"
input ItemSizeCategoryTimelineSortInput {
  "Field to sort by"
  field: ItemSizeCategoryTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ItemSizeCategory timeline"
type ItemSizeCategoryTimelinePage {
  "Timeline items for current page"
  entries: [ItemSizeCategoryTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Item Brand entity"
type ItemBrand {
  "Unique item brand identifier"
  id: ID

  "Item brand name"
  name: String!

  "Company this item brand belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated item brand response"
type ItemBrandPage {
  "List of item brands for current page"
  entries: [ItemBrand]!

  "Total number of item brands matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching item brands"
input ItemBrandFilters {
  "Filter by name (partial match)"
  name: String
}

"Available fields for sorting item brands"
enum ItemBrandSortField {
  "Sort by item brand ID"
  ID

  "Sort by name"
  NAME

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for item brands"
input ItemBrandSortInput {
  "Field to sort by"
  field: ItemBrandSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item brand input"
input CreateItemBrandInput {
  "Item brand name"
  name: String!
}

"Update item brand data"
input UpdateItemBrandInput {
  "Item brand name"
  name: String
}

"Item brand creation response"
type CreateItemBrandPayload {
  "Created item brand"
  itemBrand: ItemBrand

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Item brand update response"
type UpdateItemBrandPayload {
  "Updated item brand"
  itemBrand: ItemBrand

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Item brand deletion response"
type DeleteItemBrandPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted item brand ID"
  deletedId: ID
}

"Humanized field-level change for ItemBrand"
type ItemBrandChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an ItemBrand"
type ItemBrandTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemBrandChange]!
}

"Filters for ItemBrand timeline"
input ItemBrandTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ItemBrand timeline"
enum ItemBrandTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ItemBrand timeline"
input ItemBrandTimelineSortInput {
  "Field to sort by"
  field: ItemBrandTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ItemBrand timeline"
type ItemBrandTimelinePage {
  "Timeline items for current page"
  entries: [ItemBrandTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Response for can delete item brand"
type CanDeleteItemBrandPayload {
  "Whether the item brand can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Inventory Item Sub Category"
type ItemSubCategory {
  "Unique item sub category identifier"
  id: ID

  "Item sub category name"
  name: String

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime

  "Parent item category this sub category belongs to"
  itemCategory: ItemCategory

  "Company this item sub category belongs to"
  company: Company

  "User who created this record"
  createdBy: Account
}

"Available fields for sorting item sub categories"
enum ItemSubCategorySortField {
  "Sort by item sub category ID"
  ID

  "Sort by name"
  NAME

  "Sort by item category ID"
  ITEM_CATEGORY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for item sub categories"
input ItemSubCategorySortInput {
  "Field to sort by"
  field: ItemSubCategorySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item sub category input"
input CreateItemSubCategoryInput {
  "Item sub category name"
  name: String!

  "Item category ID"
  itemCategoryId: ID!
}

"Update item sub category input"
input UpdateItemSubCategoryInput {
  "Item sub category name"
  name: String
}

"Item sub category filters for pagination"
input ItemSubCategoryFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by item category ID"
  itemCategoryId: ID
}

"Response for item sub category creation"
type CreateItemSubCategoryPayload {
  "Created item sub category"
  itemSubCategory: ItemSubCategory

  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "Validation errors (on failure)"
  errors: [FieldError]
}

"Response for item sub category updates"
type UpdateItemSubCategoryPayload {
  "Updated item sub category"
  itemSubCategory: ItemSubCategory

  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "Validation errors (on failure)"
  errors: [FieldError]
}

"Response for item sub category deletion"
type DeleteItemSubCategoryPayload {
  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "ID of deleted item sub category (on success)"
  deletedId: ID
}

"Paginated item sub category result"
type ItemSubCategoryPage {
  "Item sub categories for current page"
  entries: [ItemSubCategory]!

  "Current page number"
  pageNumber: Int!

  "Items per page"
  pageSize: Int!

  "Total item sub categories count"
  totalEntries: Int!

  "Total pages available"
  totalPages: Int!
}

"Response for can delete item sub category"
type CanDeleteItemSubCategoryPayload {
  "Whether the item sub category can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type ItemSubCategoryChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an item sub category"
type ItemSubCategoryTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemSubCategoryChange]!
}

"Filters for ItemSubCategory timeline"
input ItemSubCategoryTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ItemSubCategory timeline"
enum ItemSubCategoryTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ItemSubCategory timeline"
input ItemSubCategoryTimelineSortInput {
  "Field to sort by"
  field: ItemSubCategoryTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ItemSubCategory timeline"
type ItemSubCategoryTimelinePage {
  "Timeline items for current page"
  entries: [ItemSubCategoryTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Inventory Item Category"
type ItemCategory {
  "Unique item category identifier"
  id: ID

  "Item category name"
  name: String

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime

  "Item type this category belongs to"
  itemType: ItemType

  "Company this item category belongs to"
  company: Company

  "User who created this record"
  createdBy: Account
}

"Available fields for sorting item categories"
enum ItemCategorySortField {
  "Sort by item category ID"
  ID

  "Sort by name"
  NAME

  "Sort by item type ID"
  ITEM_TYPE_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for item categories"
input ItemCategorySortInput {
  "Field to sort by"
  field: ItemCategorySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item category input"
input CreateItemCategoryInput {
  "Item category name"
  name: String!

  "Item type ID"
  itemTypeId: ID!
}

"Update item category input"
input UpdateItemCategoryInput {
  "Item category name"
  name: String

  "Item type ID"
  itemTypeId: ID
}

"Item category filters for pagination"
input ItemCategoryFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by item type ID"
  itemTypeId: ID
}

"Response for item category creation"
type CreateItemCategoryPayload {
  "Created item category"
  itemCategory: ItemCategory

  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "Validation errors (on failure)"
  errors: [FieldError]
}

"Response for item category updates"
type UpdateItemCategoryPayload {
  "Updated item category"
  itemCategory: ItemCategory

  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "Validation errors (on failure)"
  errors: [FieldError]
}

"Response for item category deletion"
type DeleteItemCategoryPayload {
  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "ID of deleted item category (on success)"
  deletedId: ID
}

"Paginated item category result"
type ItemCategoryPage {
  "Item categories for current page"
  entries: [ItemCategory]!

  "Current page number"
  pageNumber: Int!

  "Items per page"
  pageSize: Int!

  "Total item categories count"
  totalEntries: Int!

  "Total pages available"
  totalPages: Int!
}

"Response for can delete item category"
type CanDeleteItemCategoryPayload {
  "Whether the item category can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type ItemCategoryChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an item category"
type ItemCategoryTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemCategoryChange]!
}

"Filters for ItemCategory timeline"
input ItemCategoryTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ItemCategory timeline"
enum ItemCategoryTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ItemCategory timeline"
input ItemCategoryTimelineSortInput {
  "Field to sort by"
  field: ItemCategoryTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ItemCategory timeline"
type ItemCategoryTimelinePage {
  "Timeline items for current page"
  entries: [ItemCategoryTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Inventory Item Type"
type ItemType {
  "Unique item type identifier"
  id: ID

  "Item type name"
  name: String

  "Single uppercase character prefix for item codes"
  prefixChar: String

  "Whether this item type requires stock control"
  stockControl: Boolean

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime

  "Company this item type belongs to"
  company: Company

  "Inventory catalog for this item type"
  catalog: Catalog

  "Default measurement unit for items of this type"
  defaultMeasurementUnit: MeasurementUnit

  "Default accounting group for items of this type"
  defaultAccountingGroup: AccountingGroup

  "User who created this record"
  createdBy: Account
}

"Available fields for sorting item types"
enum ItemTypeSortField {
  "Sort by item type ID"
  ID

  "Sort by name"
  NAME

  "Sort by prefix character"
  PREFIX_CHAR

  "Sort by stock control flag"
  STOCK_CONTROL

  "Sort by catalog ID"
  CATALOG_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for item types"
input ItemTypeSortInput {
  "Field to sort by"
  field: ItemTypeSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create item type input"
input CreateItemTypeInput {
  "Item type name"
  name: String!

  "Single uppercase character prefix"
  prefixChar: String!

  "Whether this item type requires stock control"
  stockControl: Boolean!

  "Inventory catalog ID"
  catalogId: ID!

  "Default measurement unit ID"
  defaultMeasurementUnitId: ID!

  "Default accounting group ID"
  defaultAccountingGroupId: ID!
}

"Update item type input"
input UpdateItemTypeInput {
  "Item type name"
  name: String

  "Single uppercase character prefix"
  prefixChar: String

  "Whether this item type requires stock control"
  stockControl: Boolean

  "Inventory catalog ID"
  catalogId: ID

  "Default measurement unit ID"
  defaultMeasurementUnitId: ID

  "Default accounting group ID"
  defaultAccountingGroupId: ID
}

"Item type filters for pagination"
input ItemTypeFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by prefix character (exact match)"
  prefixChar: String

  "Filter by stock control requirement"
  stockControl: Boolean

  "Filter by catalog ID"
  catalogId: ID
}

"Response for item type creation"
type CreateItemTypePayload {
  "Created item type"
  itemType: ItemType

  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "Validation errors (on failure)"
  errors: [FieldError]
}

"Response for item type updates"
type UpdateItemTypePayload {
  "Updated item type"
  itemType: ItemType

  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "Validation errors (on failure)"
  errors: [FieldError]
}

"Response for item type deletion"
type DeleteItemTypePayload {
  "Operation success status"
  success: Boolean!

  "Success or error message"
  message: String

  "ID of deleted item type (on success)"
  deletedId: ID
}

"Paginated item type result"
type ItemTypePage {
  "Item types for current page"
  entries: [ItemType]!

  "Current page number"
  pageNumber: Int!

  "Items per page"
  pageSize: Int!

  "Total item types count"
  totalEntries: Int!

  "Total pages available"
  totalPages: Int!
}

"Response for can delete item type"
type CanDeleteItemTypePayload {
  "Whether the item type can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type ItemTypeChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an item type"
type ItemTypeTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ItemTypeChange]!
}

"Filters for ItemType timeline"
input ItemTypeTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ItemType timeline"
enum ItemTypeTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ItemType timeline"
input ItemTypeTimelineSortInput {
  "Field to sort by"
  field: ItemTypeTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ItemType timeline"
type ItemTypeTimelinePage {
  "Timeline items for current page"
  entries: [ItemTypeTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Measurement unit type"
enum MeasurementUnitType {
  "Length"
  LENGTH

  "Mass"
  MASS

  "Volume"
  VOLUME

  "Area"
  AREA

  "Time"
  TIME

  "Unit"
  UNIT
}

"Measurement unit entity"
type MeasurementUnit {
  "Unique measurement unit identifier"
  id: ID

  "Measurement unit name"
  name: String

  "Measurement unit abbreviation"
  abbreviation: String

  "Measurement unit type"
  type: MeasurementUnitType

  "DIAN code"
  dianCode: String

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated measurement unit response"
type MeasurementUnitPage {
  "List of measurement units for current page"
  entries: [MeasurementUnit]!

  "Total number of measurement units matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching measurement units"
input MeasurementUnitFilters {
  "Filter by measurement unit name"
  name: String

  "Filter by measurement unit abbreviation"
  abbreviation: String

  "Search in name and abbreviation"
  matching: String
}

"Available fields for sorting measurement units"
enum MeasurementUnitSortField {
  "Sort by measurement unit ID"
  ID

  "Sort by measurement unit name"
  NAME

  "Sort by measurement unit abbreviation"
  ABBREVIATION

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for measurement units"
input MeasurementUnitSortInput {
  "Field to sort by"
  field: MeasurementUnitSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create measurement unit input"
input CreateMeasurementUnitInput {
  "Measurement unit name"
  name: String!

  "Measurement unit abbreviation"
  abbreviation: String!

  "Measurement unit type"
  type: MeasurementUnitType!

  "DIAN code"
  dianCode: String!
}

"Update measurement unit data"
input UpdateMeasurementUnitInput {
  "Measurement unit name"
  name: String

  "Measurement unit abbreviation"
  abbreviation: String

  "Measurement unit type"
  type: MeasurementUnitType

  "DIAN code"
  dianCode: String
}

"Measurement unit creation response"
type CreateMeasurementUnitPayload {
  "Created measurement unit"
  measurementUnit: MeasurementUnit

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Measurement unit update response"
type UpdateMeasurementUnitPayload {
  "Updated measurement unit"
  measurementUnit: MeasurementUnit

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Measurement unit deletion response"
type DeleteMeasurementUnitPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted measurement unit ID"
  deletedId: ID
}

"Response for can delete measurement unit"
type CanDeleteMeasurementUnitPayload {
  "Whether the measurement unit can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Represents a single field change in a measurement unit timeline entry"
type MeasurementUnitChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

"Timeline entry for measurement unit audit history"
type MeasurementUnitTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [MeasurementUnitChange]!
}

"Filters for measurement unit timeline queries"
input MeasurementUnitTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

"Available fields for sorting measurement unit timeline"
enum MeasurementUnitTimelineSortField {
  RECORDED_AT
  ACTION
}

"Sort configuration for measurement unit timeline"
input MeasurementUnitTimelineSortInput {
  field: MeasurementUnitTimelineSortField!
  direction: SortDirection!
}

"Paginated timeline response for measurement units"
type MeasurementUnitTimelinePage {
  entries: [MeasurementUnitTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Inventory Catalog entity"
type Catalog {
  "Unique inventory catalog identifier"
  id: ID

  "Inventory catalog name"
  name: String!

  "Company this inventory catalog belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated inventory catalog response"
type CatalogPage {
  "List of inventory catalogs for current page"
  entries: [Catalog]!

  "Total number of inventory catalogs matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching inventory catalogs"
input CatalogFilters {
  "Filter by name (partial match)"
  name: String
}

"Available fields for sorting inventory catalogs"
enum CatalogSortField {
  "Sort by inventory catalog ID"
  ID

  "Sort by name"
  NAME

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for inventory catalogs"
input CatalogSortInput {
  "Field to sort by"
  field: CatalogSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create catalog input"
input CreateCatalogInput {
  "Catalog name"
  name: String!
}

"Update catalog data"
input UpdateCatalogInput {
  "Catalog name"
  name: String
}

"Catalog creation response"
type CreateCatalogPayload {
  "Created catalog"
  catalog: Catalog

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Catalog update response"
type UpdateCatalogPayload {
  "Updated catalog"
  catalog: Catalog

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Catalog deletion response"
type DeleteCatalogPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted catalog ID"
  deletedId: ID
}

"Response for can delete catalog"
type CanDeleteCatalogPayload {
  "Whether the catalog can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Catalog"
type CatalogChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Catalog"
type CatalogTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CatalogChange]!
}

"Filters for Catalog timeline"
input CatalogTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Catalog timeline"
enum CatalogTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Catalog timeline"
input CatalogTimelineSortInput {
  "Field to sort by"
  field: CatalogTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Catalog timeline"
type CatalogTimelinePage {
  "Timeline items for current page"
  entries: [CatalogTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

type TreasuryConfig {
  id: ID
  company: Company
  createdBy: Account
  cashGroupAccountingAccount: AccountingAccount
  checkGroupAccountingAccount: AccountingAccount
  cardGroupAccountingAccount: AccountingAccount
  savingsGroupAccountingAccount: AccountingAccount
  checkingGroupAccountingAccount: AccountingAccount
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

input CreateTreasuryConfigInput {
  cashGroupAccountingAccountId: ID!
  checkGroupAccountingAccountId: ID!
  cardGroupAccountingAccountId: ID!
  savingsGroupAccountingAccountId: ID!
  checkingGroupAccountingAccountId: ID!
}

input UpdateTreasuryConfigInput {
  cashGroupAccountingAccountId: ID
  checkGroupAccountingAccountId: ID
  cardGroupAccountingAccountId: ID
  savingsGroupAccountingAccountId: ID
  checkingGroupAccountingAccountId: ID
}

type CreateTreasuryConfigPayload {
  treasuryConfig: TreasuryConfig
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateTreasuryConfigPayload {
  treasuryConfig: TreasuryConfig
  success: Boolean!
  message: String
  errors: [FieldError]
}

type TreasuryConfigChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

type TreasuryConfigTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [TreasuryConfigChange]!
}

input TreasuryConfigTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

enum TreasuryConfigTimelineSortField {
  RECORDED_AT
  ACTION
}

input TreasuryConfigTimelineSortInput {
  field: TreasuryConfigTimelineSortField!
  direction: SortDirection!
}

type TreasuryConfigTimelinePage {
  entries: [TreasuryConfigTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Franchise by cost center entity"
type FranchiseByCostCenter {
  "Unique identifier"
  id: ID

  "Commission rate"
  commissionRate: Decimal

  "ReteIVA rate"
  reteivaRate: Decimal

  "ReteICA rate"
  reteicaRate: Decimal

  "ReteFTE rate"
  retefteRate: Decimal

  "Tax rate"
  taxRate: Decimal

  "Commission formula"
  formulaCommission: String

  "ReteIVA formula"
  formulaReteiva: String

  "ReteICA formula"
  formulaReteica: String

  "ReteFTE formula"
  formulaRetefte: String

  "Cost center"
  costCenter: CostCenter

  "Franchise"
  franchise: Franchise

  "Commission accounting account"
  commissionAccountingAccount: AccountingAccount

  "Bank account"
  bankAccount: BankAccount

  "Company this franchise by cost center belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Create franchise by cost center input"
input CreateFranchiseByCostCenterInput {
  "Cost center ID"
  costCenterId: ID!

  "Franchise ID"
  franchiseId: ID!

  "Bank account ID"
  bankAccountId: ID!

  "Commission accounting account ID"
  commissionAccountingAccountId: ID!

  "Commission rate"
  commissionRate: Decimal

  "ReteIVA rate"
  reteivaRate: Decimal

  "ReteICA rate"
  reteicaRate: Decimal

  "ReteFTE rate"
  retefteRate: Decimal

  "Tax rate"
  taxRate: Decimal

  "Commission formula"
  formulaCommission: String

  "ReteIVA formula"
  formulaReteiva: String

  "ReteICA formula"
  formulaReteica: String

  "ReteFTE formula"
  formulaRetefte: String
}

"Update franchise by cost center data"
input UpdateFranchiseByCostCenterInput {
  "Commission rate"
  commissionRate: Decimal

  "ReteIVA rate"
  reteivaRate: Decimal

  "ReteICA rate"
  reteicaRate: Decimal

  "ReteFTE rate"
  retefteRate: Decimal

  "Tax rate"
  taxRate: Decimal

  "Commission accounting account ID"
  commissionAccountingAccountId: ID

  "Bank account ID"
  bankAccountId: ID

  "Commission formula"
  formulaCommission: String

  "ReteIVA formula"
  formulaReteiva: String

  "ReteICA formula"
  formulaReteica: String

  "ReteFTE formula"
  formulaRetefte: String
}

"Franchise by cost center creation response"
type CreateFranchiseByCostCenterPayload {
  "Created franchise by cost center"
  franchiseByCostCenter: FranchiseByCostCenter

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Franchise by cost center update response"
type UpdateFranchiseByCostCenterPayload {
  "Updated franchise by cost center"
  franchiseByCostCenter: FranchiseByCostCenter

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Franchise by cost center deletion response"
type DeleteFranchiseByCostCenterPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted franchise by cost center ID"
  deletedId: ID
}

"Franchise type"
enum FranchiseType {
  "TD"
  TD

  "TC"
  TC
}

"Franchise entity"
type Franchise {
  "Unique franchise identifier"
  id: ID

  "Franchise name"
  name: String

  "Type"
  type: FranchiseType

  "Commission rate"
  commissionRate: Decimal

  "ReteIVA rate"
  reteivaRate: Decimal

  "ReteICA rate"
  reteicaRate: Decimal

  "ReteFTE rate"
  retefteRate: Decimal

  "Tax rate"
  taxRate: Decimal

  "Commission accounting account"
  commissionAccountingAccount: AccountingAccount

  "Bank account"
  bankAccount: BankAccount

  "Commission formula"
  formulaCommission: String

  "ReteIVA formula"
  formulaReteiva: String

  "ReteICA formula"
  formulaReteica: String

  "ReteFTE formula"
  formulaRetefte: String

  "Company this franchise belongs to"
  company: Company

  "Cost center configurations for this franchise"
  franchisesByCostCenter: [FranchiseByCostCenter]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated franchises response"
type FranchisePage {
  "List of franchises for current page"
  entries: [Franchise]!

  "Total number of franchises matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching franchises"
input FranchiseFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by type"
  type: FranchiseType

  "Search in name"
  matching: String
}

"Available fields for sorting franchises"
enum FranchiseSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by type"
  TYPE

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for franchises"
input FranchiseSortInput {
  "Field to sort by"
  field: FranchiseSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create franchise input"
input CreateFranchiseInput {
  "Franchise name"
  name: String!

  "Type"
  type: FranchiseType!

  "Commission rate"
  commissionRate: Decimal

  "ReteIVA rate"
  reteivaRate: Decimal

  "ReteICA rate"
  reteicaRate: Decimal

  "ReteFTE rate"
  retefteRate: Decimal

  "Tax rate"
  taxRate: Decimal

  "Commission accounting account ID"
  commissionAccountingAccountId: ID!

  "Bank account ID"
  bankAccountId: ID!

  "Commission formula"
  formulaCommission: String

  "ReteIVA formula"
  formulaReteiva: String

  "ReteICA formula"
  formulaReteica: String

  "ReteFTE formula"
  formulaRetefte: String
}

"Update franchise data"
input UpdateFranchiseInput {
  "Franchise name"
  name: String

  "Type"
  type: FranchiseType

  "Commission rate"
  commissionRate: Decimal

  "ReteIVA rate"
  reteivaRate: Decimal

  "ReteICA rate"
  reteicaRate: Decimal

  "ReteFTE rate"
  retefteRate: Decimal

  "Tax rate"
  taxRate: Decimal

  "Commission accounting account ID"
  commissionAccountingAccountId: ID

  "Bank account ID"
  bankAccountId: ID

  "Commission formula"
  formulaCommission: String

  "ReteIVA formula"
  formulaReteiva: String

  "ReteICA formula"
  formulaReteica: String

  "ReteFTE formula"
  formulaRetefte: String
}

"Franchise creation response"
type CreateFranchisePayload {
  "Created franchise"
  franchise: Franchise

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Franchise update response"
type UpdateFranchisePayload {
  "Updated franchise"
  franchise: Franchise

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Franchise deletion response"
type DeleteFranchisePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted franchise ID"
  deletedId: ID
}

"Response for can delete franchise"
type CanDeleteFranchisePayload {
  "Whether the franchise can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

type FranchiseChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

type FranchiseTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [FranchiseChange]!
}

input FranchiseTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

enum FranchiseTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

input FranchiseTimelineSortInput {
  "Field to sort by"
  field: FranchiseTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

type FranchiseTimelinePage {
  "Timeline items for current page"
  entries: [FranchiseTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Concept type enum"
enum TreasuryConceptType {
  "Ingreso"
  I

  "Egreso"
  E

  "Descuento"
  D
}

"Concept entity"
type TreasuryConcept {
  id: ID

  name: String

  allowMargin: Boolean

  margin: Decimal

  marginBasis: Int

  type: TreasuryConceptType

  company: Company

  accountingAccount: AccountingAccount

  "User who created this record"
  createdBy: Account

  insertedAt: IsoDatetime

  updatedAt: IsoDatetime
}

"Paginated concept response"
type TreasuryConceptPage {
  entries: [TreasuryConcept]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for searching concepts"
input TreasuryConceptFilters {
  name: String
  type: TreasuryConceptType
  accountingAccountId: ID
  allowMargin: Boolean
  marginBasis: Int
}

"Available fields for sorting concepts"
enum TreasuryConceptSortField {
  ID
  NAME
  TYPE
  ALLOW_MARGIN
  MARGIN
  MARGIN_BASIS
  ACCOUNTING_ACCOUNT_ID
  INSERTED_AT
  UPDATED_AT
}

"Sort configuration for concepts"
input TreasuryConceptSortInput {
  field: TreasuryConceptSortField!
  direction: SortDirection!
}

"Create concept input"
input CreateTreasuryConceptInput {
  name: String!
  type: TreasuryConceptType!
  accountingAccountId: ID!
  allowMargin: Boolean
  margin: Decimal
  marginBasis: Int
}

"Update concept input"
input UpdateTreasuryConceptInput {
  name: String
  type: TreasuryConceptType
  accountingAccountId: ID
  allowMargin: Boolean
  margin: Decimal
  marginBasis: Int
}

"Concept creation response"
type CreateTreasuryConceptPayload {
  concept: TreasuryConcept
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Concept update response"
type UpdateTreasuryConceptPayload {
  concept: TreasuryConcept
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Concept deletion response"
type DeleteTreasuryConceptPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete concept"
type CanDeleteTreasuryConceptPayload {
  canDelete: Boolean!
  message: String
}

"Humanized field-level change"
type TreasuryConceptChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

"Timeline item for a concept"
type TreasuryConceptTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [TreasuryConceptChange]!
}

"Filters for Concept timeline"
input TreasuryConceptTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

"Sort fields for Concept timeline"
enum TreasuryConceptTimelineSortField {
  RECORDED_AT
  ACTION
}

"Sort configuration for Concept timeline"
input TreasuryConceptTimelineSortInput {
  field: TreasuryConceptTimelineSortField!
  direction: SortDirection!
}

"Paginated response for Concept timeline"
type TreasuryConceptTimelinePage {
  entries: [TreasuryConceptTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Cash drawer entity"
type CashDrawer {
  "Unique cash drawer identifier"
  id: ID

  "Cash drawer name"
  name: String

  "Whether cash review is required"
  cashReviewRequired: Boolean

  "Auto adjust balance flag"
  autoAdjustBalance: Boolean

  "Whether performs auto transfer"
  autoTransfer: Boolean

  "Whether it is petty cash"
  isPettyCash: Boolean

  "Computer name (optional)"
  computerName: String

  "Company this cash drawer belongs to"
  company: Company

  "Related cost center"
  costCenter: CostCenter

  "Cash accounting account"
  cashAccountingAccount: AccountingAccount

  "Check accounting account"
  checkAccountingAccount: AccountingAccount

  "Card accounting account"
  cardAccountingAccount: AccountingAccount

  "Optional auto-transfer target cash drawer"
  autoTransferCashDrawer: CashDrawer

  "Parent cash drawer (optional)"
  parent: CashDrawer

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated cash drawers response"
type CashDrawerPage {
  "List of cash drawers for current page"
  entries: [CashDrawer]!

  "Total number of cash drawers matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching cash drawers"
input CashDrawerFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by computer name (partial match)"
  computerName: String

  "Filter by petty cash flag"
  isPettyCash: Boolean

  "Filter by cost center ID"
  costCenterId: ID

  "Filter by cash accounting account ID"
  cashAccountingAccountId: ID

  "Filter by check accounting account ID"
  checkAccountingAccountId: ID

  "Filter by card accounting account ID"
  cardAccountingAccountId: ID

  "Filter by parent cash drawer ID"
  parentId: ID

  "Search in name and computer_name (partial match)"
  matching: String
}

"Available fields for sorting cash drawers"
enum CashDrawerSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by computer name"
  COMPUTER_NAME

  "Sort by petty cash flag"
  IS_PETTY_CASH

  "Sort by cost center ID"
  COST_CENTER_ID

  "Sort by cash accounting account ID"
  CASH_ACCOUNTING_ACCOUNT_ID

  "Sort by check accounting account ID"
  CHECK_ACCOUNTING_ACCOUNT_ID

  "Sort by card accounting account ID"
  CARD_ACCOUNTING_ACCOUNT_ID

  "Sort by parent cash drawer ID"
  PARENT_ID

  "Sort by auto transfer cash drawer ID"
  AUTO_TRANSFER_CASH_DRAWER_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for cash drawers"
input CashDrawerSortInput {
  "Field to sort by"
  field: CashDrawerSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create cash drawer input"
input CreateCashDrawerInput {
  "Cash drawer name"
  name: String!

  "Whether cash review is required"
  cashReviewRequired: Boolean

  "Auto adjust balance flag"
  autoAdjustBalance: Boolean

  "Whether performs auto transfer"
  autoTransfer: Boolean

  "Whether it is petty cash"
  isPettyCash: Boolean

  "Computer name (optional)"
  computerName: String

  "Related cost center ID"
  costCenterId: ID!

  "Optional auto-transfer target cash drawer ID"
  autoTransferCashDrawerId: ID

  "Parent cash drawer ID (optional)"
  parentId: ID
}

"Update cash drawer data"
input UpdateCashDrawerInput {
  "Cash drawer name"
  name: String

  "Whether cash review is required"
  cashReviewRequired: Boolean

  "Auto adjust balance flag"
  autoAdjustBalance: Boolean

  "Whether performs auto transfer"
  autoTransfer: Boolean

  "Whether it is petty cash"
  isPettyCash: Boolean

  "Computer name (optional)"
  computerName: String

  "Related cost center ID"
  costCenterId: ID

  "Cash accounting account ID"
  cashAccountingAccountId: ID

  "Check accounting account ID"
  checkAccountingAccountId: ID

  "Card accounting account ID"
  cardAccountingAccountId: ID

  "Optional auto-transfer target cash drawer ID"
  autoTransferCashDrawerId: ID

  "Parent cash drawer ID (optional)"
  parentId: ID
}

"Cash drawer creation response"
type CreateCashDrawerPayload {
  "Created cash drawer"
  cashDrawer: CashDrawer

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Cash drawer update response"
type UpdateCashDrawerPayload {
  "Updated cash drawer"
  cashDrawer: CashDrawer

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Cash drawer deletion response"
type DeleteCashDrawerPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted cash drawer ID"
  deletedId: ID
}

"Response for can delete cash drawer"
type CanDeleteCashDrawerPayload {
  "Whether the cash drawer can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type CashDrawerChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a cash drawer"
type CashDrawerTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CashDrawerChange]!
}

"Filters for CashDrawer timeline"
input CashDrawerTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for CashDrawer timeline"
enum CashDrawerTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for CashDrawer timeline"
input CashDrawerTimelineSortInput {
  "Field to sort by"
  field: CashDrawerTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for CashDrawer timeline"
type CashDrawerTimelinePage {
  "Timeline items for current page"
  entries: [CashDrawerTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Bank account type"
enum BankAccountType {
  "Ahorro"
  A

  "Corriente"
  C

  "Plataforma Movil"
  M
}

"Bank account provider"
enum BankAccountProvider {
  "Daviplata"
  D

  "Nequi"
  N

  "No aplica"
  EMPTY
}

"Bank account entity"
type BankAccount {
  "Unique bank account identifier"
  id: ID

  "Account type: A=Ahorro, C=Corriente, M=Plataforma Movil"
  type: BankAccountType

  "Account number"
  number: String

  "Whether bank account is active"
  isActive: Boolean

  "Whether to enable automatic payment method behavior for this bank account"
  enablePaymentMethod: Boolean

  "Account description"
  description: String

  "Account reference"
  reference: String

  "Display order for sorting"
  displayOrder: Int

  "Provider: D=Daviplata, N=Nequi, EMPTY=Sin proveedor"
  provider: BankAccountProvider

  "Company this bank account belongs to"
  company: Company

  "Associated bank"
  bank: Bank

  "Associated accounting account"
  accountingAccount: AccountingAccount

  "Associated payment method"
  paymentMethod: PaymentMethod

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated bank account response"
type BankAccountPage {
  "List of bank accounts for current page"
  entries: [BankAccount]!

  "Total number of bank accounts matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching bank accounts"
input BankAccountFilters {
  "Filter by account types (A, C, M) - include only these types"
  types: [BankAccountType]

  "Filter by account number (partial match)"
  number: String

  "Filter by active status"
  isActive: Boolean

  "Filter by description (partial match)"
  description: String

  "Filter by reference (partial match)"
  reference: String

  "Filter by provider (D, N, EMPTY)"
  provider: BankAccountProvider

  "Filter by bank ID"
  bankId: ID

  "Filter by accounting account ID"
  accountingAccountId: ID

  "Filter by payment method ID"
  paymentMethodId: ID

  "Search in number, description and reference"
  matching: String
}

"Available fields for sorting bank accounts"
enum BankAccountSortField {
  "Sort by bank account ID"
  ID

  "Sort by account number"
  ACCOUNT_NUMBER

  "Sort by active status"
  IS_ACTIVE

  "Sort by account description"
  DESCRIPTION

  "Sort by account reference"
  REFERENCE

  "Sort by display order"
  DISPLAY_ORDER

  "Sort by bank ID"
  BANK_ID

  "Sort by accounting account ID"
  ACCOUNTING_ACCOUNT_ID

  "Sort by payment method ID"
  PAYMENT_METHOD_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for bank accounts"
input BankAccountSortInput {
  "Field to sort by"
  field: BankAccountSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create bank account input"
input CreateBankAccountInput {
  "Account type: A=Ahorro, C=Corriente, M=Plataforma Movil"
  type: BankAccountType!

  "Account number"
  number: String!

  "Whether bank account is active"
  isActive: Boolean

  "Whether to enable automatic payment method behavior for this bank account"
  enablePaymentMethod: Boolean

  "Account description"
  description: String!

  "Account reference"
  reference: String

  "Display order for sorting"
  displayOrder: Int

  "Provider: D=Daviplata, N=Nequi, EMPTY=Sin proveedor"
  provider: BankAccountProvider

  "Associated bank ID"
  bankId: ID!

  "Associated accounting account ID"
  accountingAccountId: ID
}

"Update bank account data"
input UpdateBankAccountInput {
  "Whether bank account is active"
  isActive: Boolean

  "Whether to enable automatic payment method behavior for this bank account"
  enablePaymentMethod: Boolean

  "Account description"
  description: String

  "Account reference"
  reference: String

  "Display order for sorting"
  displayOrder: Int

  "Associated accounting account ID"
  accountingAccountId: ID

  "Associated payment method ID"
  paymentMethodId: ID
}

"Bank account creation response"
type CreateBankAccountPayload {
  "Created bank account"
  bankAccount: BankAccount

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Bank account update response"
type UpdateBankAccountPayload {
  "Updated bank account"
  bankAccount: BankAccount

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Bank account deletion response"
type DeleteBankAccountPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted bank account ID"
  deletedId: ID
}

"Response for can delete bank account"
type CanDeleteBankAccountPayload {
  "Whether the bank account can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type BankAccountChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a bank account"
type BankAccountTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [BankAccountChange]!
}

"Filters for BankAccount timeline"
input BankAccountTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for BankAccount timeline"
enum BankAccountTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for BankAccount timeline"
input BankAccountTimelineSortInput {
  "Field to sort by"
  field: BankAccountTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for BankAccount timeline"
type BankAccountTimelinePage {
  "Timeline items for current page"
  entries: [BankAccountTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Bank entity"
type Bank {
  "Unique bank identifier"
  id: ID

  "Bank code (3 numeric characters)"
  code: String

  "Payment method prefix (1 letter)"
  paymentMethodPrefix: String

  "Company this bank belongs to"
  company: Company

  "Associated accounting entity"
  accountingEntity: AccountingEntity

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated bank response"
type BankPage {
  "List of banks for current page"
  entries: [Bank]!

  "Total number of banks matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching banks"
input BankFilters {
  "Filter by exact bank code"
  code: String

  "Filter by payment method prefix"
  paymentMethodPrefix: String

  "Filter by accounting entity ID"
  accountingEntityId: ID

  "Search in bank code"
  matching: String
}

"Available fields for sorting banks"
enum BankSortField {
  "Sort by bank ID"
  ID

  "Sort by bank code"
  CODE

  "Sort by payment method prefix"
  PAYMENT_METHOD_PREFIX

  "Sort by accounting entity ID"
  ACCOUNTING_ENTITY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for banks"
input BankSortInput {
  "Field to sort by"
  field: BankSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create bank input"
input CreateBankInput {
  "Bank code (3 numeric characters)"
  code: String!

  "Payment method prefix (1 letter)"
  paymentMethodPrefix: String!

  "Associated accounting entity ID"
  accountingEntityId: ID!
}

"Update bank data"
input UpdateBankInput {
  "Payment method prefix (1 letter)"
  paymentMethodPrefix: String

  "Associated accounting entity ID"
  accountingEntityId: ID
}

"Bank creation response"
type CreateBankPayload {
  "Created bank"
  bank: Bank

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Bank update response"
type UpdateBankPayload {
  "Updated bank"
  bank: Bank

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Bank deletion response"
type DeleteBankPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted bank ID"
  deletedId: ID
}

"Response for can delete bank"
type CanDeleteBankPayload {
  "Whether the bank can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change"
type BankChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a bank"
type BankTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [BankChange]!
}

"Filters for Bank timeline"
input BankTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Bank timeline"
enum BankTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Bank timeline"
input BankTimelineSortInput {
  "Field to sort by"
  field: BankTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Bank timeline"
type BankTimelinePage {
  "Timeline items for current page"
  entries: [BankTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Supplier entity"
type Supplier {
  "Unique supplier identifier"
  id: ID

  "Whether supplier is tax free"
  isTaxFree: Boolean

  "ICA withholding rate percentage"
  icaWithholdingRate: Decimal

  "Whether ICA withholding applies on any amount"
  withholdingAppliesOnAnyAmount: Boolean

  "Company this supplier belongs to"
  company: Company

  "Associated accounting entity"
  accountingEntity: AccountingEntity

  "ICA accounting account"
  icaAccountingAccount: AccountingAccount

  "Withholding types associated to this supplier"
  withholdingTypes: [WithholdingType]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated supplier response"
type SupplierPage {
  "List of suppliers for current page"
  entries: [Supplier]!

  "Total number of suppliers matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching suppliers"
input SupplierFilters {
  "Filter by tax free status"
  isTaxFree: Boolean

  "Filter by ICA withholding applies on any amount"
  withholdingAppliesOnAnyAmount: Boolean

  "Filter by accounting entity ID"
  accountingEntityId: ID

  "Filter by ICA accounting account ID"
  icaAccountingAccountId: ID

  "Search by identification number or name (partial match)"
  matching: String
}

"Available fields for sorting suppliers"
enum SupplierSortField {
  "Sort by supplier ID"
  ID

  "Sort by tax free status"
  IS_TAX_FREE

  "Sort by ICA withholding applies on any amount"
  WITHHOLDING_APPLIES_ON_ANY_AMOUNT

  "Sort by ICA withholding rate"
  ICA_WITHHOLDING_RATE

  "Sort by accounting entity ID"
  ACCOUNTING_ENTITY_ID

  "Sort by ICA accounting account ID"
  ICA_ACCOUNTING_ACCOUNT_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for suppliers"
input SupplierSortInput {
  "Field to sort by"
  field: SupplierSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create supplier input"
input CreateSupplierInput {
  "Whether supplier is tax free"
  isTaxFree: Boolean

  "ICA withholding rate percentage"
  icaWithholdingRate: Decimal

  "Whether ICA withholding applies on any amount"
  withholdingAppliesOnAnyAmount: Boolean

  "Accounting entity data"
  accountingEntity: CreateAccountingEntityInput

  "ICA accounting account ID"
  icaAccountingAccountId: ID

  "Withholding type IDs to associate"
  withholdingTypeIds: [ID]
}

"Update supplier input"
input UpdateSupplierInput {
  "Whether supplier is tax free"
  isTaxFree: Boolean

  "ICA withholding rate percentage"
  icaWithholdingRate: Decimal

  "Whether ICA withholding applies on any amount"
  withholdingAppliesOnAnyAmount: Boolean

  "Accounting entity data"
  accountingEntity: UpdateAccountingEntityInput

  "ICA accounting account ID"
  icaAccountingAccountId: ID

  "Withholding type IDs to associate"
  withholdingTypeIds: [ID]
}

"Supplier creation response"
type CreateSupplierPayload {
  "Created supplier"
  supplier: Supplier

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Supplier update response"
type UpdateSupplierPayload {
  "Updated supplier"
  supplier: Supplier

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Supplier deletion response"
type DeleteSupplierPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted supplier ID"
  deletedId: ID
}

"Response for can delete supplier"
type CanDeleteSupplierPayload {
  "Whether the supplier can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Price list detail entity"
type PriceListDetail {
  id: ID
  price: Decimal
  discountMargin: Decimal
  profitMargin: Decimal
  minimumPrice: Decimal
  priceList: PriceList
  item: Item
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Price list entity"
type PriceList {
  id: ID

  name: String

  editablePrice: Boolean

  isActive: Boolean

  autoApplyDiscount: Boolean

  isPublic: Boolean

  allowNewUsersAccess: Boolean

  listUpdateBehaviorOnCostChange: String

  parent: PriceList

  startDate: IsoDatetime

  endDate: IsoDatetime

  isTaxable: Boolean

  priceListIncludeTax: Boolean

  useAlternativeFormula: Boolean

  archived: Boolean

  company: Company

  storage: Storage

  details: [PriceListDetail]

  "Payment methods excluded from this price list"
  excludedPaymentMethods: [PaymentMethod]

  "User who created this record"
  createdBy: Account

  insertedAt: IsoDatetime

  updatedAt: IsoDatetime
}

"Paginated price list response"
type PriceListPage {
  entries: [PriceList]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for searching price lists"
input PriceListFilters {
  name: String
  isActive: Boolean
  storageId: ID
  matching: String
}

"Available fields for sorting price lists"
enum PriceListSortField {
  ID
  NAME
  EDITABLE_PRICE
  IS_ACTIVE
  AUTO_APPLY_DISCOUNT
  IS_PUBLIC
  ALLOW_NEW_USERS_ACCESS
  LIST_UPDATE_BEHAVIOR_ON_COST_CHANGE
  PARENT_ID
  START_DATE
  END_DATE
  IS_TAXABLE
  PRICE_LIST_INCLUDE_TAX
  USE_ALTERNATIVE_FORMULA
  STORAGE_ID
  ARCHIVED
  INSERTED_AT
  UPDATED_AT
}

"Sort configuration for price lists"
input PriceListSortInput {
  field: PriceListSortField!
  direction: SortDirection!
}

"Create price list input"
input CreatePriceListInput {
  name: String!

  editablePrice: Boolean

  isActive: Boolean

  autoApplyDiscount: Boolean

  isPublic: Boolean

  allowNewUsersAccess: Boolean

  listUpdateBehaviorOnCostChange: String

  parentId: ID

  startDate: IsoDatetime

  endDate: IsoDatetime

  isTaxable: Boolean

  priceListIncludeTax: Boolean

  useAlternativeFormula: Boolean

  archived: Boolean

  storageId: ID!

  "Payment method IDs to exclude (full replace on create)"
  excludedPaymentMethodIds: [ID]
}

"Update price list input"
input UpdatePriceListInput {
  name: String

  editablePrice: Boolean

  isActive: Boolean

  autoApplyDiscount: Boolean

  isPublic: Boolean

  allowNewUsersAccess: Boolean

  listUpdateBehaviorOnCostChange: String

  parentId: ID

  startDate: IsoDatetime

  endDate: IsoDatetime

  isTaxable: Boolean

  priceListIncludeTax: Boolean

  useAlternativeFormula: Boolean

  archived: Boolean

  storageId: ID

  "Payment method IDs to exclude (full replace on update)"
  excludedPaymentMethodIds: [ID]
}

"Price list creation response"
type CreatePriceListPayload {
  priceList: PriceList
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Price list update response"
type UpdatePriceListPayload {
  priceList: PriceList
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Price list deletion response"
type DeletePriceListPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete price list"
type CanDeletePriceListPayload {
  "Whether the price list can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

type PriceListChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

type PriceListTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [PriceListChange]!
}

input PriceListTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

enum PriceListTimelineSortField {
  RECORDED_AT
  ACTION
}

input PriceListTimelineSortInput {
  field: PriceListTimelineSortField!
  direction: SortDirection!
}

type PriceListTimelinePage {
  entries: [PriceListTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Item to update in a price list (partial fields allowed)"
input PriceListPriceItemInput {
  itemId: ID!
  price: Decimal
  discountMargin: Decimal
  profitMargin: Decimal
  minimumPrice: Decimal
}

"Batch update input for price list prices"
input BatchUpdatePriceListPricesInput {
  priceListId: ID!
  items: [PriceListPriceItemInput!]!
}

"Batch update result"
type BatchUpdatePriceListPricesPayload {
  success: Boolean!
  message: String
  createdCount: Int!
  updatedCount: Int!
  errors: [FieldError]
  details: [PriceListDetail]
}

"Additional discount type entity"
type AdditionalDiscountType {
  id: ID

  code: String

  name: String

  description: String

  discountRate: Decimal

  applicationOrder: Int

  isCumulative: Boolean

  hasDateRange: Boolean

  startDate: Date

  endDate: Date

  isActive: Boolean

  company: Company

  "User who created this record"
  createdBy: Account

  insertedAt: IsoDatetime

  updatedAt: IsoDatetime
}

"Paginated additional discount types response"
type AdditionalDiscountTypePage {
  entries: [AdditionalDiscountType]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for additional discount types"
input AdditionalDiscountTypeFilters {
  code: String
  name: String
  isActive: Boolean
}

"Sort fields for additional discount types"
enum AdditionalDiscountTypeSortField {
  ID
  CODE
  NAME
  APPLICATION_ORDER
  IS_CUMULATIVE
  HAS_DATE_RANGE
  IS_ACTIVE
  INSERTED_AT
  UPDATED_AT
}

"Sort configuration for additional discount types"
input AdditionalDiscountTypeSortInput {
  field: AdditionalDiscountTypeSortField!
  direction: SortDirection!
}

"Create additional discount type input"
input CreateAdditionalDiscountTypeInput {
  code: String!
  name: String!
  description: String
  discountRate: Decimal!
  applicationOrder: Int
  isCumulative: Boolean
  hasDateRange: Boolean
  startDate: Date
  endDate: Date
  isActive: Boolean
}

"Update additional discount type input"
input UpdateAdditionalDiscountTypeInput {
  code: String
  name: String
  description: String
  discountRate: Decimal
  applicationOrder: Int
  isCumulative: Boolean
  hasDateRange: Boolean
  startDate: Date
  endDate: Date
  isActive: Boolean
}

type CreateAdditionalDiscountTypePayload {
  additionalDiscountType: AdditionalDiscountType
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateAdditionalDiscountTypePayload {
  additionalDiscountType: AdditionalDiscountType
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteAdditionalDiscountTypePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete additional discount type"
type CanDeleteAdditionalDiscountTypePayload {
  "Whether the discount type can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Invoice entity"
type Invoice {
  id: ID
  businessDocumentId: ID
  number: String
  cufe: String
  operationType: String
  invoiceTypeCode: String
  issueDate: IsoDatetime
  issueTime: Time
  dueDate: IsoDatetime
  invoicePeriodStart: Date
  invoicePeriodEnd: Date
  currencyCode: CurrencyCode
  baseCurrencyCode: CurrencyCode
  exchangeRate: Decimal
  exchangeRateDate: Date
  currencyRoundingAdjustment: Decimal
  purchaseOrderReference: String
  purchaseOrderDate: Date
  paymentTerms: String
  deliveryTerms: String
  lineCount: Int
  totalAiuAdministration: Decimal
  totalAiuUnforeseen: Decimal
  totalAiuProfit: Decimal
  totalAiu: Decimal
  subtotal: Decimal
  totalDiscounts: Decimal
  totalTaxes: Decimal
  totalWithholdings: Decimal
  totalAmount: Decimal
  totalCost: Decimal
  prepaidAmount: Decimal
  paidAmount: Decimal
  balanceDue: Decimal
  previousBalance: Decimal
  cashReceived: Decimal
  changeGiven: Decimal
  deviceName: String
  note: String
  company: Company
  costCenter: CostCenter
  authorizationSequence: AuthorizationSequence
  customer: Customer
  seller: Seller
  cashDrawer: CashDrawer
  accountingSource: AccountingSource
  receivableAccount: AccountingAccount
  createdBy: Account
  lines: [InvoiceLine]
  paymentMethods: [InvoicePaymentMethod]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Invoice line entity"
type InvoiceLine {
  id: ID
  extendedInformation: String
  quantity: Decimal
  price: Decimal
  listPrice: Decimal
  minimumListPrice: Decimal
  cost: Decimal
  isAiu: Boolean
  aiuAdministrationRate: Decimal
  aiuUnforeseenRate: Decimal
  aiuProfitRate: Decimal
  aiuBaseAmount: Decimal
  aiuAdministrationAmount: Decimal
  aiuUnforeseenAmount: Decimal
  aiuProfitAmount: Decimal
  aiuTotalAmount: Decimal
  paidAmount: Decimal
  balanceDue: Decimal
  currencyRoundingAdjustment: Decimal
  invoice: Invoice
  item: Item
  size: ItemSizeValue
  lot: Lot
  storage: Storage
  receivableAccount: AccountingAccount
  taxes: [InvoiceLineTax]
  discounts: [InvoiceLineDiscount]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Invoice line tax entity"
type InvoiceLineTax {
  id: ID
  taxName: String
  taxRate: Decimal
  taxableAmount: Decimal
  taxAmount: Decimal
  invoiceLine: InvoiceLine
  tax: Tax
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Invoice line discount entity"
type InvoiceLineDiscount {
  id: ID
  discountSource: String
  discountName: String
  discountOrder: Int
  discountRate: Decimal
  baseAmount: Decimal
  discountAmount: Decimal
  invoiceLine: InvoiceLine
  discountType: AdditionalDiscountType
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Invoice payment method entity"
type InvoicePaymentMethod {
  id: ID
  number: String
  amount: Decimal
  invoice: Invoice
  paymentMethod: PaymentMethod
}

"Paginated invoices response"
type InvoicePage {
  entries: [Invoice]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for invoices"
input InvoiceFilters {
  number: String
  cufe: String
  customerId: ID
  issueDateFrom: IsoDatetime
  issueDateTo: IsoDatetime
}

"Invoice sort fields"
enum InvoiceSortField {
  ID
  NUMBER
  CUFE
  ISSUE_DATE
  DUE_DATE
  CUSTOMER_ID
  SELLER_ID
  AUTHORIZATION_SEQUENCE_ID
  TOTAL_AMOUNT
  INSERTED_AT
  UPDATED_AT
}

input InvoiceSortInput {
  field: InvoiceSortField!
  direction: SortDirection!
}

"Input for creating an invoice line tax"
input CreateInvoiceLineTaxInput {
  taxId: ID!
  taxRate: Decimal!
}

"Input for creating an invoice line discount"
input CreateInvoiceLineDiscountInput {
  "ID del tipo de descuento adicional (billing.additional_discount_types)"
  discountTypeId: ID

  "Porcentaje de descuento manual (si no se usa discount_type_id)"
  discountRate: Decimal

  "Monto fijo de descuento manual (si no se usa discount_type_id ni porcentaje)"
  discountAmount: Decimal

  "Nombre personalizado para descuento manual"
  name: String
}

"Input for creating an invoice line"
input CreateInvoiceLineInput {
  itemId: ID!

  sizeId: ID

  lotId: ID

  storageId: ID

  quantity: Decimal!

  unitPrice: Decimal!

  taxes: [CreateInvoiceLineTaxInput]

  "Descuentos a aplicar (tipos adicionales o manuales)"
  discounts: [CreateInvoiceLineDiscountInput]

  "AIU - Administracin, Imprevistos, Utilidad (Art. 462-1 E.T.)"
  aiuAdministrationRate: Decimal

  aiuUnforeseenRate: Decimal

  aiuProfitRate: Decimal
}

"Input for creating an invoice payment method"
input CreateInvoicePaymentMethodInput {
  paymentMethodId: ID!
  amount: Decimal!
}

"Input for creating an invoice via SqlPipeline"
input CreateInvoiceInput {
  costCenterId: ID!
  authorizationSequenceId: ID!
  customerId: ID!
  sellerId: ID!
  cashDrawerId: ID!
  accountingSourceId: ID!
  storageId: ID!
  priceListId: ID
  receivableAccountId: ID
  issueDate: IsoDatetime
  issueTime: Time
  dueDate: IsoDatetime!
  currencyCode: CurrencyCode!
  baseCurrencyCode: CurrencyCode!
  exchangeRate: Decimal
  exchangeRateDate: Date
  cufe: String
  operationType: String
  invoiceTypeCode: String
  purchaseOrderReference: String
  purchaseOrderDate: Date
  paymentTerms: String
  deliveryTerms: String
  deviceName: String!
  note: String
  lines: [CreateInvoiceLineInput!]!
  paymentMethods: [CreateInvoicePaymentMethodInput!]!
}

input UpdateInvoiceInput {
  costCenterId: ID
  authorizationSequenceId: ID
  customerId: ID
  sellerId: ID
  priceListId: ID
  cashDrawerId: ID
  receivableAccountId: ID
  number: String
  cufe: String
  operationType: String
  invoiceTypeCode: String
  issueDate: IsoDatetime
  issueTime: Time
  dueDate: IsoDatetime
  currencyCode: CurrencyCode
  baseCurrencyCode: CurrencyCode
  purchaseOrderReference: String
  purchaseOrderDate: Date
  paymentTerms: String
  deliveryTerms: String
  note: String
  deviceName: String
}

type CreateInvoicePayload {
  invoice: Invoice
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateInvoicePayload {
  invoice: Invoice
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteInvoicePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Billing zone entity"
type Zone {
  "Unique billing zone identifier"
  id: ID

  "Billing zone name"
  name: String

  "Whether billing zone is active"
  isActive: Boolean

  "Company this billing zone belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated billing zone response"
type ZonePage {
  "List of billing zones for current page"
  entries: [Zone]!

  "Total number of billing zones matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching billing zones"
input ZoneFilters {
  "Filter by billing zone name (partial match)"
  name: String

  "Filter by active status"
  isActive: Boolean
}

"Available fields for sorting billing zones"
enum ZoneSortField {
  "Sort by billing zone ID"
  ID

  "Sort by billing zone name"
  NAME

  "Sort by active status"
  IS_ACTIVE

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for billing zones"
input ZoneSortInput {
  "Field to sort by"
  field: ZoneSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create zone input"
input CreateZoneInput {
  "Zone name"
  name: String!

  "Whether zone is active"
  isActive: Boolean
}

"Update zone data"
input UpdateZoneInput {
  "Zone name"
  name: String

  "Whether zone is active"
  isActive: Boolean
}

"Zone creation response"
type CreateZonePayload {
  "Created zone"
  zone: Zone

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Zone update response"
type UpdateZonePayload {
  "Updated zone"
  zone: Zone

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Zone deletion response"
type DeleteZonePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted zone ID"
  deletedId: ID
}

"Response for can delete zone"
type CanDeleteZonePayload {
  "Whether the zone can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Audit action"
enum AuditAction {
  "Entity was created"
  CREATED

  "Entity was updated"
  UPDATED

  "Entity was deleted"
  DELETED
}

"Audit change operation"
enum AuditOp {
  "Field was added"
  ADDED

  "Field value changed"
  CHANGED

  "Field was removed"
  REMOVED

  "Unknown change operation"
  UNKNOWN
}

"Humanized field-level change"
type ZoneChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a zone"
type ZoneTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ZoneChange]!
}

"Filters for Zone timeline"
input ZoneTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Zone timeline"
enum ZoneTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Zone timeline"
input ZoneTimelineSortInput {
  "Field to sort by"
  field: ZoneTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Zone timeline"
type ZoneTimelinePage {
  "Timeline items for current page"
  entries: [ZoneTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Seller entity"
type Seller {
  "Unique seller identifier"
  id: ID

  "Whether seller is active"
  isActive: Boolean

  "Company this seller belongs to"
  company: Company

  "Associated accounting entity"
  accountingEntity: AccountingEntity

  "Associated zone"
  zone: Zone

  "Associated cost centers"
  costCenters: [CostCenter]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated seller response"
type SellerPage {
  "List of sellers for current page"
  entries: [Seller]!

  "Total number of sellers matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching sellers"
input SellerFilters {
  "Filter by active status"
  isActive: Boolean

  "Filter by accounting entity ID"
  accountingEntityId: ID

  "Filter by billing zone ID"
  zoneId: ID

  "Filter by cost center ID"
  costCenterId: ID

  "Search by identification number or name (partial match)"
  matching: String
}

"Available fields for sorting sellers"
enum SellerSortField {
  "Sort by seller ID"
  ID

  "Sort by active status"
  IS_ACTIVE

  "Sort by accounting entity ID"
  ACCOUNTING_ENTITY_ID

  "Sort by zone ID"
  ZONE_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for sellers"
input SellerSortInput {
  "Field to sort by"
  field: SellerSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create seller input"
input CreateSellerInput {
  "Whether seller is active"
  isActive: Boolean

  "Accounting entity data"
  accountingEntity: CreateAccountingEntityInput!

  "Optional zone to associate"
  zoneId: ID

  "List of cost center IDs to associate with the seller"
  costCenterIds: [ID!]
}

"Update seller data"
input UpdateSellerInput {
  "Whether seller is active"
  isActive: Boolean

  "Optional billing zone to associate or clear (nil)"
  zoneId: ID

  "Accounting entity data to update"
  accountingEntity: UpdateAccountingEntityInput

  "List of cost center IDs to associate with the seller"
  costCenterIds: [ID!]
}

"Seller creation response"
type CreateSellerPayload {
  "Created seller"
  seller: Seller

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Seller update response"
type UpdateSellerPayload {
  "Updated seller"
  seller: Seller

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Seller deletion response"
type DeleteSellerPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted seller ID"
  deletedId: ID
}

"Response for can delete seller"
type CanDeleteSellerPayload {
  "Whether the seller can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Seller"
type SellerChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Seller"
type SellerTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [SellerChange]!
}

"Filters for Seller timeline"
input SellerTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Seller timeline"
enum SellerTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Seller timeline"
input SellerTimelineSortInput {
  "Field to sort by"
  field: SellerTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Seller timeline"
type SellerTimelinePage {
  "Timeline items for current page"
  entries: [SellerTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Customer entity"
type Customer {
  "Unique customer identifier"
  id: ID

  "Credit term in days"
  creditTerm: Int

  "Whether customer is tax free"
  isTaxFree: Boolean

  "Whether customer is active"
  isActive: Boolean

  "Reason for blocking customer"
  blockingReason: String

  "Whether customer retains any basis"
  retainsAnyBasis: Boolean

  "Company this customer belongs to"
  company: Company

  "Associated accounting entity"
  accountingEntity: AccountingEntity

  "Associated billing zone (optional)"
  zone: Zone

  "Withholding types associated to this customer"
  withholdingTypes: [WithholdingType]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated customer response"
type CustomerPage {
  "List of customers for current page"
  entries: [Customer]!

  "Total number of customers matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching customers"
input CustomerFilters {
  "Filter by credit term"
  creditTerm: Int

  "Filter by tax free status"
  isTaxFree: Boolean

  "Filter by active status"
  isActive: Boolean

  "Filter by retains any basis status"
  retainsAnyBasis: Boolean

  "Filter by accounting entity ID"
  accountingEntityId: ID

  "Filter by billing zone ID"
  zoneId: ID

  "Search across multiple fields"
  matching: String
}

"Available fields for sorting customers"
enum CustomerSortField {
  "Sort by customer ID"
  ID

  "Sort by credit term"
  CREDIT_TERM

  "Sort by tax free status"
  IS_TAX_FREE

  "Sort by active status"
  IS_ACTIVE

  "Sort by blocking reason"
  BLOCKING_REASON

  "Sort by retains any basis status"
  RETAINS_ANY_BASIS

  "Sort by accounting entity ID"
  ACCOUNTING_ENTITY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for customers"
input CustomerSortInput {
  "Field to sort by"
  field: CustomerSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create customer input"
input CreateCustomerInput {
  "Credit term in days"
  creditTerm: Int

  "Whether customer is tax free"
  isTaxFree: Boolean

  "Whether customer is active"
  isActive: Boolean

  "Reason for blocking customer"
  blockingReason: String

  "Whether customer retains any basis"
  retainsAnyBasis: Boolean

  "Accounting entity data"
  accountingEntity: CreateAccountingEntityInput

  "Optional zone ID"
  zoneId: ID

  "Withholding types to associate (full replace on create)"
  withholdingTypeIds: [ID]
}

"Update customer data"
input UpdateCustomerInput {
  "Credit term in days"
  creditTerm: Int

  "Whether customer is tax free"
  isTaxFree: Boolean

  "Whether customer is active"
  isActive: Boolean

  "Reason for blocking customer"
  blockingReason: String

  "Whether customer retains any basis"
  retainsAnyBasis: Boolean

  "Optional zone ID to assign"
  zoneId: ID

  "Accounting entity data to update"
  accountingEntity: UpdateAccountingEntityInput

  "Withholding types to associate (full replace on update)"
  withholdingTypeIds: [ID]
}

"Customer creation response"
type CreateCustomerPayload {
  "Created customer"
  customer: Customer

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Customer update response"
type UpdateCustomerPayload {
  "Updated customer"
  customer: Customer

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Customer deletion response"
type DeleteCustomerPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted customer ID"
  deletedId: ID
}

"Response for can delete customer"
type CanDeleteCustomerPayload {
  "Whether the customer can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Customer"
type CustomerChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Customer"
type CustomerTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CustomerChange]!
}

"Filters for Customer timeline"
input CustomerTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Customer timeline"
enum CustomerTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Customer timeline"
input CustomerTimelineSortInput {
  "Field to sort by"
  field: CustomerTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Customer timeline"
type CustomerTimelinePage {
  "Timeline items for current page"
  entries: [CustomerTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Payment method entity"
type PaymentMethod {
  "Unique payment method identifier"
  id: ID

  "Payment method name"
  name: String

  "Payment method abbreviation (2 characters)"
  abbreviation: String

  "Whether document number is required"
  requiresDocumentNumber: Boolean

  "Whether payment method is credit"
  isCredit: Boolean

  "Whether payment method is active"
  isActive: Boolean

  "Display order for sorting"
  displayOrder: Int

  "Company this payment method belongs to"
  company: Company

  "Associated accounting account"
  accountingAccount: AccountingAccount

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated payment method response"
type PaymentMethodPage {
  "List of payment methods for current page"
  entries: [PaymentMethod]!

  "Total number of payment methods matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching payment methods"
input PaymentMethodFilters {
  "Filter by payment method name (partial match)"
  name: String

  "Filter by abbreviation (exact match)"
  abbreviation: String

  "Filter by credit status"
  isCredit: Boolean

  "Filter by active status"
  isActive: Boolean

  "Filter by document number requirement"
  requiresDocumentNumber: Boolean

  "Search in both name and abbreviation"
  matching: String
}

"Available fields for sorting payment methods"
enum PaymentMethodSortField {
  "Sort by payment method ID"
  ID

  "Sort by payment method name"
  NAME

  "Sort by abbreviation"
  ABBREVIATION

  "Sort by document number requirement"
  REQUIRES_DOCUMENT_NUMBER

  "Sort by credit status"
  IS_CREDIT

  "Sort by active status"
  IS_ACTIVE

  "Sort by display order"
  DISPLAY_ORDER

  "Sort by accounting account ID"
  ACCOUNTING_ACCOUNT_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for payment methods"
input PaymentMethodSortInput {
  "Field to sort by"
  field: PaymentMethodSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create payment method input"
input CreatePaymentMethodInput {
  "Payment method name"
  name: String!

  "Payment method abbreviation (2 characters)"
  abbreviation: String!

  "Whether document number is required"
  requiresDocumentNumber: Boolean

  "Whether payment method is credit"
  isCredit: Boolean

  "Whether payment method is active"
  isActive: Boolean

  "Display order for sorting"
  displayOrder: Int

  "Associated accounting account ID"
  accountingAccountId: ID
}

"Update payment method data"
input UpdatePaymentMethodInput {
  "Payment method name"
  name: String

  "Whether document number is required"
  requiresDocumentNumber: Boolean

  "Whether payment method is credit"
  isCredit: Boolean

  "Whether payment method is active"
  isActive: Boolean

  "Display order for sorting"
  displayOrder: Int

  "Associated accounting account ID"
  accountingAccountId: ID
}

"Payment method creation response"
type CreatePaymentMethodPayload {
  "Created payment method"
  paymentMethod: PaymentMethod

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Payment method update response"
type UpdatePaymentMethodPayload {
  "Updated payment method"
  paymentMethod: PaymentMethod

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Payment method deletion response"
type DeletePaymentMethodPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted payment method ID"
  deletedId: ID
}

"Response for can delete payment method"
type CanDeletePaymentMethodPayload {
  "Whether the payment method can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for payment method"
type PaymentMethodChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a payment method"
type PaymentMethodTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [PaymentMethodChange]!
}

"Filters for Payment Method timeline"
input PaymentMethodTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Payment Method timeline"
enum PaymentMethodTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Payment Method timeline"
input PaymentMethodTimelineSortInput {
  "Field to sort by"
  field: PaymentMethodTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Payment Method timeline"
type PaymentMethodTimelinePage {
  "Timeline items for current page"
  entries: [PaymentMethodTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Comprobante contable (encabezado)"
type AccountingEntry {
  id: ID
  documentDate: IsoDate
  documentNumber: String
  description: String
  state: String
  annulment: Boolean
  company: Company
  accountingBook: AccountingBook
  costCenter: CostCenter
  accountingSource: AccountingSource
  createdBy: Account
  cancelledBy: Account
  reverse: AccountingEntry
  lines: [AccountingEntryLine]
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Paginated accounting entries response"
type AccountingEntryPage {
  entries: [AccountingEntry]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for searching accounting entries"
input AccountingEntryFilters {
  documentNumber: String
  description: String
  state: String
  annulment: Boolean
  accountingBookId: ID
  costCenterId: ID
  accountingSourceId: ID
  createdById: ID
  reverseId: ID
  fromDocumentDate: IsoDate
  toDocumentDate: IsoDate
  matching: String
}

"Available fields for sorting accounting entries"
enum AccountingEntrySortField {
  ID
  DOCUMENT_DATE
  DOCUMENT_NUMBER
  STATE
  ANNULMENT
  INSERTED_AT
  UPDATED_AT
}

"Sort configuration for accounting entries"
input AccountingEntrySortInput {
  field: AccountingEntrySortField!
  direction: SortDirection!
}

"Lnea del comprobante contable"
input AccountingEntryLineInput {
  accountingAccountId: ID!
  accountingEntityId: ID!
  costCenterId: ID!
  recordDetail: String!
  debit: Decimal
  credit: Decimal
  base: Decimal
}

"Entrada (encabezado) para crear comprobante contable"
input CreateAccountingEntryWithLinesInput {
  accountingBookId: ID!
  costCenterId: ID!
  accountingSourceId: ID!
  documentDate: IsoDate!
  documentNumber: String!
  description: String
  state: String
  createdById: ID!
  reverseId: ID
  lines: [AccountingEntryLineInput!]!
}

"Payload de creacin de comprobante contable"
type CreateAccountingEntryWithLinesPayload {
  accountingEntry: AccountingEntry
  insertedLinesCount: Int
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Entrada (encabezado) para crear borrador de comprobante contable"
input CreateAccountingEntryDraftInput {
  accountingBookId: ID!
  costCenterId: ID!
  accountingSourceId: ID!
  documentDate: IsoDate!
  documentNumber: String
  description: String
  masterId: ID
  createdById: ID!
}

"Payload de creacin de borrador de comprobante contable"
type CreateAccountingEntryDraftPayload {
  draft: AccountingEntryDraft
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Input para finalizar un borrador de comprobante"
input FinalizeAccountingEntryDraftInput {
  draftId: ID!
}

"Payload de finalizacin de borrador"
type FinalizeAccountingEntryDraftPayload {
  accountingEntry: AccountingEntry
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Input para eliminar lneas especficas de un borrador"
input DeleteDraftLinesInput {
  draftId: ID!
  lineIds: [ID!]!
}

"Payload de eliminacin de lneas de borrador"
type DeleteDraftLinesPayload {
  deletedCount: Int
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Input para eliminar todas las lneas de un borrador"
input ClearDraftLinesInput {
  draftId: ID!
}

"Payload de limpieza de lneas de borrador"
type ClearDraftLinesPayload {
  deletedCount: Int
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Borrador de comprobante contable"
type AccountingEntryDraft {
  id: ID
  documentDate: IsoDate
  documentNumber: String
  description: String
  accountingBook: AccountingBook
  costCenter: CostCenter
  accountingSource: AccountingSource
  createdBy: Account
  master: AccountingEntry
  insertedAt: IsoDatetime
  updatedAt: IsoDatetime
}

"Paginated accounting entry drafts response"
type AccountingEntryDraftPage {
  entries: [AccountingEntryDraft]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for searching accounting entry drafts"
input AccountingEntryDraftFilters {
  documentNumber: String
  description: String
  accountingBookId: ID
  costCenterId: ID
  accountingSourceId: ID
  masterId: ID
  fromDocumentDate: IsoDate
  toDocumentDate: IsoDate
  matching: String
}

"Available fields for sorting accounting entry drafts"
enum AccountingEntryDraftSortField {
  ID
  DOCUMENT_DATE
  DOCUMENT_NUMBER
  INSERTED_AT
  UPDATED_AT
}

"Sort configuration for accounting entry drafts"
input AccountingEntryDraftSortInput {
  field: AccountingEntryDraftSortField!
  direction: SortDirection!
}

"Lnea de borrador de comprobante contable"
type AccountingEntryDraftLine {
  id: ID
  accountingEntryDraft: AccountingEntryDraft
  accountingAccount: AccountingAccount
  accountingEntity: AccountingEntity
  costCenter: CostCenter
  recordDetail: String
  debit: Decimal
  credit: Decimal
  base: Decimal
  detail: AccountingEntryLine
}

"Lnea del comprobante contable (solo lectura)"
type AccountingEntryLine {
  id: ID
  recordDetail: String
  debit: Decimal
  credit: Decimal
  base: Decimal
  accountingAccount: AccountingAccount
  accountingEntity: AccountingEntity
  costCenter: CostCenter
  accountingEntry: AccountingEntry
}

"Input para actualizar un borrador de comprobante"
input UpdateDraftInput {
  draftId: ID!
  documentDate: IsoDate
  documentNumber: String
  description: String
  accountingBookId: ID
  costCenterId: ID
  accountingSourceId: ID
}

"Payload de actualizacin de borrador"
type UpdateDraftPayload {
  draft: AccountingEntryDraft
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Input para actualizar una lnea de borrador"
input UpdateDraftLineInput {
  draftId: ID!
  lineId: ID!
  accountingAccountId: ID
  accountingEntityId: ID
  costCenterId: ID
  recordDetail: String
  debit: Decimal
  credit: Decimal
  base: Decimal
}

"Payload de actualizacin de lnea de borrador"
type UpdateDraftLinePayload {
  line: AccountingEntryDraftLine
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Lnea para upsert (con id opcional para actualizacin)"
input UpsertDraftLineInput {
  "Si se proporciona, actualiza la lnea existente"
  id: ID

  accountingAccountId: ID

  accountingEntityId: ID

  costCenterId: ID

  recordDetail: String

  debit: Decimal

  credit: Decimal

  base: Decimal
}

"Input para upsert de lneas de borrador"
input UpsertDraftLinesInput {
  draftId: ID!
  lines: [UpsertDraftLineInput!]!
}

"Payload de upsert de lneas de borrador"
type UpsertDraftLinesPayload {
  insertedCount: Int
  updatedCount: Int
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Withholding type entity"
type WithholdingType {
  "Unique withholding type identifier"
  id: ID

  "Withholding type name"
  name: String

  "Withholding group classification (RTFTE\/RTICA\/RTIVA)"
  withholdingGroup: WithholdingGroup

  "Base amount threshold from which withholding applies"
  baseAmountFrom: Decimal

  "Calculation base (100 or 1000)"
  baseCalculationType: Int

  "Withholding rate percentage (0-100)"
  withholdingRate: Decimal

  company: Company

  purchaseAccountingAccount: AccountingAccount

  saleAccountingAccount: AccountingAccount

  selfWithholdingSaleAccountingAccount: AccountingAccount

  "User who created this record"
  createdBy: Account

  insertedAt: IsoDatetime

  updatedAt: IsoDatetime
}

"Paginated withholding type response"
type WithholdingTypePage {
  entries: [WithholdingType]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for searching withholding types"
input WithholdingTypeFilters {
  name: String
  withholdingGroup: WithholdingGroup
  matching: String
}

"Available fields for sorting withholding types"
enum WithholdingTypeSortField {
  ID
  NAME
  WITHHOLDING_GROUP
  BASE_AMOUNT_FROM
  BASE_CALCULATION_TYPE
  WITHHOLDING_RATE
  PURCHASE_ACCOUNTING_ACCOUNT_ID
  SALE_ACCOUNTING_ACCOUNT_ID
  SELF_WITHHOLDING_SALE_ACCOUNTING_ACCOUNT_ID
  INSERTED_AT
  UPDATED_AT
}

"Sort configuration for withholding types"
input WithholdingTypeSortInput {
  field: WithholdingTypeSortField!
  direction: SortDirection!
}

"Create withholding type input"
input CreateWithholdingTypeInput {
  name: String!
  withholdingGroup: WithholdingGroup!
  baseAmountFrom: Decimal!
  baseCalculationType: Int!
  withholdingRate: Decimal!
  purchaseAccountingAccountId: ID!
  saleAccountingAccountId: ID!
  selfWithholdingSaleAccountingAccountId: ID
}

"Update withholding type data"
input UpdateWithholdingTypeInput {
  name: String
  withholdingGroup: WithholdingGroup
  baseAmountFrom: Decimal
  baseCalculationType: Int
  withholdingRate: Decimal
  purchaseAccountingAccountId: ID
  saleAccountingAccountId: ID
  selfWithholdingSaleAccountingAccountId: ID
}

"Enum for withholding groups"
enum WithholdingGroup {
  "RETENCIN EN LA FUENTE"
  RTFTE

  "RETENCIN DE ICA"
  RTICA

  "RETENCIN DE IVA"
  RTIVA
}

"Withholding type creation response"
type CreateWithholdingTypePayload {
  withholdingType: WithholdingType
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Withholding type update response"
type UpdateWithholdingTypePayload {
  withholdingType: WithholdingType
  success: Boolean!
  message: String
  errors: [FieldError]
}

"Withholding type deletion response"
type DeleteWithholdingTypePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Humanized field-level change for WithholdingType"
type WithholdingTypeChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

"Timeline item for a WithholdingType"
type WithholdingTypeTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [WithholdingTypeChange]!
}

"Filters for WithholdingType timeline"
input WithholdingTypeTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

"Sort fields for WithholdingType timeline"
enum WithholdingTypeTimelineSortField {
  RECORDED_AT
  ACTION
}

"Sort configuration for WithholdingType timeline"
input WithholdingTypeTimelineSortInput {
  field: WithholdingTypeTimelineSortField!
  direction: SortDirection!
}

"Paginated response for WithholdingType timeline"
type WithholdingTypeTimelinePage {
  entries: [WithholdingTypeTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Kardex flow type"
enum KardexFlow {
  "Entrada"
  I

  "Salida"
  O
}

"Annulment character type"
enum AnnulmentCharacter {
  "Anulacin con documento adicional"
  A

  "Anulacin sin documento adicional"
  X
}

"Accounting source entity (principal rows only in queries)"
type AccountingSource {
  id: ID

  code: String

  annulmentCode: String

  name: String

  isSystemSource: Boolean

  annulmentCharacter: AnnulmentCharacter

  isKardexTransaction: Boolean

  kardexFlow: KardexFlow

  annulment: Boolean

  company: Company

  processType: ProcessType

  documentSequence: DocumentSequence

  accountingAccount: AccountingAccount

  reverseAccountingSource: AccountingSource

  "User who created this record"
  createdBy: Account

  insertedAt: IsoDatetime

  updatedAt: IsoDatetime
}

"Paginated accounting sources"
type AccountingSourcePage {
  entries: [AccountingSource]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Filters for accounting sources"
input AccountingSourceFilters {
  code: String
  name: String
  annulment: Boolean
  isSystemSource: Boolean
  kardexFlow: KardexFlow
  processTypeId: ID
  moduleId: ID
}

"Sort fields for accounting sources"
enum AccountingSourceSortField {
  ID
  CODE
  NAME
  INSERTED_AT
  UPDATED_AT
}

input AccountingSourceSortInput {
  field: AccountingSourceSortField!
  direction: SortDirection!
}

"Create accounting source input (principal only)"
input CreateAccountingSourceInput {
  code: String!
  name: String!
  isSystemSource: Boolean
  annulmentCharacter: AnnulmentCharacter!
  isKardexTransaction: Boolean!
  kardexFlow: KardexFlow
  accountingAccountId: ID
  processTypeId: ID!
}

"Update accounting source input"
input UpdateAccountingSourceInput {
  name: String
  annulmentCharacter: AnnulmentCharacter
  isKardexTransaction: Boolean
  kardexFlow: KardexFlow
  accountingAccountId: ID
}

type CreateAccountingSourcePayload {
  accountingSource: AccountingSource
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateAccountingSourcePayload {
  accountingSource: AccountingSource
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteAccountingSourcePayload {
  success: Boolean!
  message: String
  deletedId: ID
}

type CanDeleteAccountingSourcePayload {
  canDelete: Boolean!
  message: String
}

"Humanized field-level change for AccountingSource"
type AccountingSourceChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

"Timeline item for an AccountingSource"
type AccountingSourceTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingSourceChange]!
}

"Filters for AccountingSource timeline"
input AccountingSourceTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

"Sort fields for AccountingSource timeline"
enum AccountingSourceTimelineSortField {
  RECORDED_AT
  ACTION
}

"Sort config for AccountingSource timeline"
input AccountingSourceTimelineSortInput {
  field: AccountingSourceTimelineSortField!
  direction: SortDirection!
}

"Paginated response for AccountingSource timeline"
type AccountingSourceTimelinePage {
  entries: [AccountingSourceTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Withholding certificate entity"
type WithholdingCertificate {
  "Unique withholding certificate identifier"
  id: ID

  "Certificate name"
  name: String

  "Certificate description"
  description: String

  "Company this certificate belongs to"
  company: Company

  "Cost center this certificate belongs to"
  costCenter: CostCenter

  "Accounting accounts linked to this withholding certificate"
  accountingAccounts: [AccountingAccount]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated withholding certificate response"
type WithholdingCertificatePage {
  "List of certificates for current page"
  entries: [WithholdingCertificate]!

  "Total number of certificates matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching withholding certificates"
input WithholdingCertificateFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by description (partial match)"
  description: String

  "Filter by name or description (partial match)"
  matching: String

  "Filter by cost center (ID)"
  costCenterId: ID
}

"Available fields for sorting withholding certificates"
enum WithholdingCertificateSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by description"
  DESCRIPTION

  "Sort by cost center id"
  COST_CENTER_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for withholding certificates"
input WithholdingCertificateSortInput {
  "Field to sort by"
  field: WithholdingCertificateSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create withholding certificate input"
input CreateWithholdingCertificateInput {
  "Certificate name"
  name: String!

  "Certificate description"
  description: String!

  "Cost center reference"
  costCenterId: ID!

  "Accounting account IDs to associate on create"
  accountingAccountIds: [ID]
}

"Update withholding certificate input"
input UpdateWithholdingCertificateInput {
  "Certificate name"
  name: String

  "Certificate description"
  description: String

  "Cost center reference"
  costCenterId: ID

  "Full replacement list of accounting account IDs to associate"
  accountingAccountIds: [ID]
}

"Withholding certificate creation response"
type CreateWithholdingCertificatePayload {
  "Created certificate"
  withholdingCertificate: WithholdingCertificate

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Withholding certificate update response"
type UpdateWithholdingCertificatePayload {
  "Updated certificate"
  withholdingCertificate: WithholdingCertificate

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Withholding certificate deletion response"
type DeleteWithholdingCertificatePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted certificate ID"
  deletedId: ID
}

"Attach accounting account to withholding certificate response"
type AttachAccountToWithholdingCertificatePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Detach accounting account from withholding certificate response"
type DetachAccountFromWithholdingCertificatePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Response for can delete withholding certificate"
type CanDeleteWithholdingCertificatePayload {
  "Whether the certificate can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for WithholdingCertificate"
type WithholdingCertificateChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a WithholdingCertificate"
type WithholdingCertificateTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [WithholdingCertificateChange]!
}

"Filters for WithholdingCertificate timeline"
input WithholdingCertificateTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for WithholdingCertificate timeline"
enum WithholdingCertificateTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for WithholdingCertificate timeline"
input WithholdingCertificateTimelineSortInput {
  "Field to sort by"
  field: WithholdingCertificateTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for WithholdingCertificate timeline"
type WithholdingCertificateTimelinePage {
  "Timeline items for current page"
  entries: [WithholdingCertificateTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Accounting account group entity"
type AccountingAccountGroup {
  "Unique accounting account group identifier"
  id: ID

  "Accounting account group name"
  name: String

  "Key to uniquely identify this group within a company"
  key: String

  "Company this accounting account group belongs to"
  company: Company

  "Accounting accounts associated to this group"
  accounts: [AccountingAccount]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated accounting account group response"
type AccountingAccountGroupPage {
  "List of accounting account groups for current page"
  entries: [AccountingAccountGroup]!

  "Total number of accounting account groups matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching accounting account groups"
input AccountingAccountGroupFilters {
  "Filter by group name (partial match)"
  name: String

  "Filter by key (partial match)"
  key: String
}

"Available fields for sorting accounting account groups"
enum AccountingAccountGroupSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by key"
  KEY

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for accounting account groups"
input AccountingAccountGroupSortInput {
  "Field to sort by"
  field: AccountingAccountGroupSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create accounting account group input"
input CreateAccountingAccountGroupInput {
  "Group name"
  name: String!

  "Group key (unique per company)"
  key: String!
}

"Update accounting account group data"
input UpdateAccountingAccountGroupInput {
  "Group name"
  name: String

  "Group key (unique per company)"
  key: String
}

"Create accounting account group with accounts input"
input CreateAccountingAccountGroupWithAccountsInput {
  "Group name"
  name: String!

  "Group key (unique per company)"
  key: String!

  "List of accounting account IDs to link to the group"
  accounts: [ID!]!
}

"Update accounting account group with accounts input"
input UpdateAccountingAccountGroupWithAccountsInput {
  "Group name"
  name: String

  "Group key (unique per company)"
  key: String

  "New full list of accounting account IDs to sync for this group"
  accounts: [ID!]!
}

"Accounting account group creation response"
type CreateAccountingAccountGroupPayload {
  "Created accounting account group"
  accountingAccountGroup: AccountingAccountGroup

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting account group update response"
type UpdateAccountingAccountGroupPayload {
  "Updated accounting account group"
  accountingAccountGroup: AccountingAccountGroup

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting account group deletion response"
type DeleteAccountingAccountGroupPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted accounting account group ID"
  deletedId: ID
}

"Response for can delete accounting account group"
type CanDeleteAccountingAccountGroupPayload {
  "Whether the accounting account group can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for AccountingAccountGroup"
type AccountingAccountGroupChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AccountingAccountGroup"
type AccountingAccountGroupTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingAccountGroupChange]!
}

"Filters for AccountingAccountGroup timeline"
input AccountingAccountGroupTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AccountingAccountGroup timeline"
enum AccountingAccountGroupTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AccountingAccountGroup timeline"
input AccountingAccountGroupTimelineSortInput {
  "Field to sort by"
  field: AccountingAccountGroupTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AccountingAccountGroup timeline"
type AccountingAccountGroupTimelinePage {
  "Timeline items for current page"
  entries: [AccountingAccountGroupTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Accounting group entity"
type AccountingGroup {
  "Unique accounting group identifier"
  id: ID

  "Accounting group name"
  name: String

  "Whether AIU (Administration, Unforeseen, Utility) is allowed"
  allowAiu: Boolean

  "Company this accounting group belongs to"
  company: Company

  "Income accounting account"
  accountIncome: AccountingAccount

  "Cost accounting account"
  accountCost: AccountingAccount

  "Inventory accounting account"
  accountInventory: AccountingAccount

  "Income reverse accounting account"
  accountIncomeReverse: AccountingAccount

  "Primary buy tax"
  buyTax1: Tax

  "Primary sell tax"
  sellTax1: Tax

  "AIU administration account (optional)"
  accountAiuAdministration: AccountingAccount

  "AIU unforeseen account (optional)"
  accountAiuUnforeseen: AccountingAccount

  "AIU utility account (optional)"
  accountAiuUtility: AccountingAccount

  "Secondary buy tax (optional)"
  buyTax2: Tax

  "Secondary sell tax category (optional)"
  sellTax2: TaxCategory

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated accounting group response"
type AccountingGroupPage {
  "List of accounting groups for current page"
  entries: [AccountingGroup]!

  "Total number of accounting groups matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching accounting groups"
input AccountingGroupFilters {
  "Filter by accounting group name"
  name: String

  "Filter by AIU allowance status"
  allowAiu: Boolean
}

"Create accounting group input"
input CreateAccountingGroupInput {
  "Accounting group name"
  name: String!

  "Whether AIU (Administration, Unforeseen, Utility) is allowed"
  allowAiu: Boolean!

  "Income accounting account ID"
  accountIncomeId: ID!

  "Cost accounting account ID"
  accountCostId: ID!

  "Inventory accounting account ID"
  accountInventoryId: ID!

  "Income reverse accounting account ID"
  accountIncomeReverseId: ID!

  "Primary buy tax ID"
  buyTaxId1: ID!

  "Primary sell tax ID"
  sellTaxId1: ID!

  "AIU administration account ID (optional)"
  accountAiuAdministrationId: ID

  "AIU unforeseen account ID (optional)"
  accountAiuUnforeseenId: ID

  "AIU utility account ID (optional)"
  accountAiuUtilityId: ID

  "Secondary buy tax ID (optional)"
  buyTaxId2: ID

  "Secondary sell tax type ID (optional)"
  sellTaxId2: ID
}

"Update accounting group data"
input UpdateAccountingGroupInput {
  "Accounting group name"
  name: String

  "Whether AIU (Administration, Unforeseen, Utility) is allowed"
  allowAiu: Boolean

  "Income accounting account ID"
  accountIncomeId: ID

  "Cost accounting account ID"
  accountCostId: ID

  "Inventory accounting account ID"
  accountInventoryId: ID

  "Income reverse accounting account ID"
  accountIncomeReverseId: ID

  "Primary buy tax ID"
  buyTaxId1: ID

  "Primary sell tax ID"
  sellTaxId1: ID

  "AIU administration account ID (optional)"
  accountAiuAdministrationId: ID

  "AIU unforeseen account ID (optional)"
  accountAiuUnforeseenId: ID

  "AIU utility account ID (optional)"
  accountAiuUtilityId: ID

  "Secondary buy tax ID (optional)"
  buyTaxId2: ID

  "Secondary sell tax type ID (optional)"
  sellTaxId2: ID
}

"Accounting group creation response"
type CreateAccountingGroupPayload {
  "Created accounting group"
  accountingGroup: AccountingGroup

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting group update response"
type UpdateAccountingGroupPayload {
  "Updated accounting group"
  accountingGroup: AccountingGroup

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting group deletion response"
type DeleteAccountingGroupPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted accounting group ID"
  deletedId: ID
}

"Response for can delete accounting group"
type CanDeleteAccountingGroupPayload {
  "Whether the accounting group can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for AccountingGroup"
type AccountingGroupChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AccountingGroup"
type AccountingGroupTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingGroupChange]!
}

"Filters for AccountingGroup timeline"
input AccountingGroupTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AccountingGroup timeline"
enum AccountingGroupTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AccountingGroup timeline"
input AccountingGroupTimelineSortInput {
  "Field to sort by"
  field: AccountingGroupTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AccountingGroup timeline"
type AccountingGroupTimelinePage {
  "Timeline items for current page"
  entries: [AccountingGroupTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Tax entity"
type Tax {
  "Unique tax identifier"
  id: ID

  "Tax name"
  name: String

  "Tax rate (percentage)"
  rate: Decimal

  "Tax active status"
  isActive: Boolean

  "Tax calculation formula"
  formula: String

  "Alternative calculation formula"
  alternativeFormula: String

  "Company this tax belongs to"
  company: Company

  "Tax category classification"
  taxCategory: TaxCategory

  "Generated tax account"
  generatedTaxAccount: AccountingAccount

  "Generated tax refund account"
  generatedTaxRefundAccount: AccountingAccount

  "Deductible tax account"
  deductibleTaxAccount: AccountingAccount

  "Deductible tax refund account"
  deductibleTaxRefundAccount: AccountingAccount

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated tax response"
type TaxPage {
  "List of taxes for current page"
  entries: [Tax]!

  "Total number of taxes matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching taxes"
input TaxFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by tax type ID"
  taxCategoryId: Int

  "Filter by active status"
  isActive: Boolean
}

"Create tax input"
input CreateTaxInput {
  "Tax name"
  name: String!

  "Tax rate (percentage)"
  rate: Decimal!

  "Tax category ID"
  taxCategoryId: ID!

  "Generated tax account ID"
  generatedTaxAccountId: ID

  "Generated tax refund account ID"
  generatedTaxRefundAccountId: ID

  "Deductible tax account ID"
  deductibleTaxAccountId: ID

  "Deductible tax refund account ID"
  deductibleTaxRefundAccountId: ID

  "Tax active status"
  isActive: Boolean

  "Tax calculation formula"
  formula: String!

  "Alternative calculation formula"
  alternativeFormula: String!
}

"Update tax data"
input UpdateTaxInput {
  "Tax name"
  name: String

  "Tax rate (percentage)"
  rate: Decimal

  "Tax category ID"
  taxCategoryId: ID

  "Generated tax account ID"
  generatedTaxAccountId: ID

  "Generated tax refund account ID"
  generatedTaxRefundAccountId: ID

  "Deductible tax account ID"
  deductibleTaxAccountId: ID

  "Deductible tax refund account ID"
  deductibleTaxRefundAccountId: ID

  "Tax active status"
  isActive: Boolean

  "Tax calculation formula"
  formula: String

  "Alternative calculation formula"
  alternativeFormula: String
}

"Tax creation response"
type CreateTaxPayload {
  "Created tax"
  tax: Tax

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Tax update response"
type UpdateTaxPayload {
  "Updated tax"
  tax: Tax

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Tax deletion response"
type DeleteTaxPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted tax ID"
  deletedId: ID
}

"Response for can delete tax"
type CanDeleteTaxPayload {
  "Whether the tax can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Tax"
type TaxChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Tax"
type TaxTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [TaxChange]!
}

"Filters for Tax timeline"
input TaxTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Tax timeline"
enum TaxTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Tax timeline"
input TaxTimelineSortInput {
  "Field to sort by"
  field: TaxTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Tax timeline"
type TaxTimelinePage {
  "Timeline items for current page"
  entries: [TaxTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Tax category entity"
type TaxCategory {
  "Unique tax category identifier"
  id: ID

  "DIAN tax code (e.g., '01' for IVA, '02' for IC)"
  code: String

  "Tax category name"
  name: String

  "Whether generated tax account is required"
  generatedTaxAccountIsRequired: Boolean

  "Whether generated tax refund account is required"
  generatedTaxRefundAccountIsRequired: Boolean

  "Whether deductible tax account is required"
  deductibleTaxAccountIsRequired: Boolean

  "Whether deductible tax refund account is required"
  deductibleTaxRefundAccountIsRequired: Boolean

  "Tax category prefix"
  prefix: String

  "Company this tax category belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated book tax type response"
type TaxCategoryPage {
  "List of book tax types for current page"
  entries: [TaxCategory]!

  "Total number of book tax types matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching book tax types"
input TaxCategoryFilters {
  "Filter by DIAN code (exact match)"
  code: String

  "Filter by name (partial match)"
  name: String

  "Filter by prefix (partial match)"
  prefix: String

  "Filter by name, code or prefix (partial match)"
  matching: String

  "Filter by generated tax account requirement"
  generatedTaxAccountIsRequired: Boolean
}

"Create book tax type input"
input CreateTaxCategoryInput {
  "DIAN tax code (2 digits, e.g., '01' for IVA)"
  code: String!

  "Tax category name"
  name: String!

  "Whether generated tax account is required"
  generatedTaxAccountIsRequired: Boolean!

  "Whether generated tax refund account is required"
  generatedTaxRefundAccountIsRequired: Boolean!

  "Whether deductible tax account is required"
  deductibleTaxAccountIsRequired: Boolean!

  "Whether deductible tax refund account is required"
  deductibleTaxRefundAccountIsRequired: Boolean!

  "Tax category prefix"
  prefix: String!
}

"Update book tax type data"
input UpdateTaxCategoryInput {
  "Tax category name"
  name: String

  "Whether generated tax account is required"
  generatedTaxAccountIsRequired: Boolean

  "Whether generated tax refund account is required"
  generatedTaxRefundAccountIsRequired: Boolean

  "Whether deductible tax account is required"
  deductibleTaxAccountIsRequired: Boolean

  "Whether deductible tax refund account is required"
  deductibleTaxRefundAccountIsRequired: Boolean

  "Tax category prefix"
  prefix: String
}

"Book tax type creation response"
type CreateTaxCategoryPayload {
  "Created book tax type"
  taxCategory: TaxCategory

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Book tax type update response"
type UpdateTaxCategoryPayload {
  "Updated book tax type"
  taxCategory: TaxCategory

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Book tax type deletion response"
type DeleteTaxCategoryPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted book tax type ID"
  deletedId: ID
}

"Response for can delete tax category"
type CanDeleteTaxCategoryPayload {
  "Whether the tax category can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for TaxCategory"
type TaxCategoryChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a TaxCategory"
type TaxCategoryTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [TaxCategoryChange]!
}

"Filters for TaxCategory timeline"
input TaxCategoryTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for TaxCategory timeline"
enum TaxCategoryTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for TaxCategory timeline"
input TaxCategoryTimelineSortInput {
  "Field to sort by"
  field: TaxCategoryTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for TaxCategory timeline"
type TaxCategoryTimelinePage {
  "Timeline items for current page"
  entries: [TaxCategoryTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Capture type for accounting entity"
enum CaptureType {
  "Persona Natural (Natural Person)"
  PN

  "Persona Jurdica (Legal Entity)"
  PJ
}

"Tax regime type"
enum TaxRegime {
  "Responsable de IVA (VAT Responsible)"
  R

  "No responsable de IVA (Non-VAT Responsible)"
  N
}

"Accounting entity"
type AccountingEntity {
  "Unique accounting entity identifier"
  id: ID

  "Identification number"
  identificationNumber: String

  "Verification digit"
  verificationDigit: String

  "Type of entity: PN (Natural Person) or PJ (Legal Entity)"
  captureType: CaptureType

  "Business name (for legal entities)"
  businessName: String

  "First name (for natural persons)"
  firstName: String

  "Middle name (for natural persons)"
  middleName: String

  "First last name (for natural persons)"
  firstLastName: String

  "Middle last name (for natural persons)"
  middleLastName: String

  "Primary phone number"
  primaryPhone: String

  "Secondary phone number"
  secondaryPhone: String

  "Primary cell phone number"
  primaryCellPhone: String

  "Secondary cell phone number"
  secondaryCellPhone: String

  "Physical address"
  address: String

  "Tax regime: R (VAT Responsible), N (Non-VAT Responsible)"
  regime: TaxRegime

  "Complete name (auto-generated)"
  fullName: String

  "Commercial trade name"
  tradeName: String

  "Searchable name (auto-generated)"
  searchName: String

  "Consolidated phone information (auto-generated)"
  telephonicInformation: String

  "Internal commercial code"
  commercialCode: String

  "Company this accounting entity belongs to"
  company: Company

  "Related identification type"
  identificationType: IdentificationType

  "Related country"
  country: Country

  "Related department"
  department: Department

  "Related city"
  city: City

  "Emails associated to this accounting entity"
  emails: [Email]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated accounting entity response"
type AccountingEntityPage {
  "List of accounting entities for current page"
  entries: [AccountingEntity]!

  "Total number of accounting entities matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching accounting entities"
input AccountingEntityFilters {
  "Filter by identification number (partial match)"
  identificationNumber: String

  "Filter by full name (partial match)"
  fullName: String

  "Filter by business name (partial match)"
  businessName: String

  "Filter by trade name (partial match)"
  tradeName: String

  "Filter by capture type (PN or PJ)"
  captureType: CaptureType

  "Filter by tax regime (R or N)"
  regime: TaxRegime

  "Filter by identification type ID"
  identificationTypeId: Int

  "Filter by country ID"
  countryId: Int

  "Filter by department ID"
  departmentId: Int

  "Filter by city ID"
  cityId: Int

  "Search across multiple fields"
  matching: String
}

"Available fields for sorting accounting entities"
enum AccountingEntitySortField {
  "Sort by accounting entity ID"
  ID

  "Sort by identification number"
  DOCUMENT_NUMBER

  "Sort by verification digit"
  VERIFICATION_DIGIT

  "Sort by capture type"
  CAPTURE_TYPE

  "Sort by business name"
  BUSINESS_NAME

  "Sort by first name"
  FIRST_NAME

  "Sort by middle name"
  MIDDLE_NAME

  "Sort by first last name"
  FIRST_LAST_NAME

  "Sort by middle last name"
  MIDDLE_LAST_NAME

  "Sort by identification type ID"
  IDENTIFICATION_TYPE_ID

  "Sort by country ID"
  COUNTRY_ID

  "Sort by department ID"
  DEPARTMENT_ID

  "Sort by city ID"
  CITY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for accounting entities"
input AccountingEntitySortInput {
  "Field to sort by"
  field: AccountingEntitySortField!

  "Sort direction"
  direction: SortDirection!
}

"Email input for creating\/updating emails of an accounting entity"
input AccountingEntityEmailInput {
  "Email description\/label"
  description: String!

  "Email address"
  email: String!

  "Password for this email account"
  password: String

  "Marks email as corporate"
  isCorporate: Boolean

  "Receives electronic invoices"
  isElectronicInvoiceRecipient: Boolean

  "SMTP server ID"
  smtpId: ID
}

"Create accounting entity input"
input CreateAccountingEntityInput {
  "Identification number (1-15 numeric characters)"
  identificationNumber: String!

  "Verification digit (1 numeric character)"
  verificationDigit: String

  "Type of entity: PN (Natural Person) or PJ (Legal Entity)"
  captureType: CaptureType!

  "Business name (required for PJ)"
  businessName: String

  "First name (required for PN)"
  firstName: String

  "Middle name (optional)"
  middleName: String

  "First last name (required for PN)"
  firstLastName: String

  "Middle last name (optional)"
  middleLastName: String

  "Primary phone number"
  primaryPhone: String

  "Secondary phone number"
  secondaryPhone: String

  "Primary cell phone number"
  primaryCellPhone: String

  "Secondary cell phone number"
  secondaryCellPhone: String

  "Physical address"
  address: String

  "Tax regime: R (VAT Responsible), N (Non-VAT Responsible)"
  regime: TaxRegime!

  "Commercial trade name"
  tradeName: String

  "Internal commercial code"
  commercialCode: String

  "Identification type ID"
  identificationTypeId: ID!

  "Country ID"
  countryId: ID!

  "Department ID"
  departmentId: ID!

  "City ID"
  cityId: ID!

  emails: [AccountingEntityEmailInput]
}

"Update accounting entity data"
input UpdateAccountingEntityInput {
  "Type of entity: PN (Natural Person) or PJ (Legal Entity)"
  captureType: CaptureType

  "Business name"
  businessName: String

  "First name"
  firstName: String

  "Middle name"
  middleName: String

  "First last name"
  firstLastName: String

  "Middle last name"
  middleLastName: String

  "Primary phone number"
  primaryPhone: String

  "Secondary phone number"
  secondaryPhone: String

  "Primary cell phone number"
  primaryCellPhone: String

  "Secondary cell phone number"
  secondaryCellPhone: String

  "Physical address"
  address: String

  "Commercial trade name"
  tradeName: String

  "Internal commercial code"
  commercialCode: String

  "Country ID"
  countryId: ID

  "Department ID"
  departmentId: ID

  "City ID"
  cityId: ID

  emails: [AccountingEntityEmailInput]
}

"Accounting entity creation response"
type CreateAccountingEntityPayload {
  "Created accounting entity"
  accountingEntity: AccountingEntity

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting entity update response"
type UpdateAccountingEntityPayload {
  "Updated accounting entity"
  accountingEntity: AccountingEntity

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting entity deletion response"
type DeleteAccountingEntityPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted accounting entity ID"
  deletedId: ID
}

"Response for can delete accounting entity"
type CanDeleteAccountingEntityPayload {
  "Whether the accounting entity can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for AccountingEntity"
type AccountingEntityChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AccountingEntity"
type AccountingEntityTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingEntityChange]!
}

"Filters for AccountingEntity timeline"
input AccountingEntityTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AccountingEntity timeline"
enum AccountingEntityTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AccountingEntity timeline"
input AccountingEntityTimelineSortInput {
  "Field to sort by"
  field: AccountingEntityTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AccountingEntity timeline"
type AccountingEntityTimelinePage {
  "Timeline items for current page"
  entries: [AccountingEntityTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Accounting presentation entity"
type AccountingPresentation {
  "Unique accounting presentation identifier"
  id: ID

  "Accounting presentation name"
  name: String

  "Whether this presentation allows closure"
  allowsClosure: Boolean

  "Accounting book used for closure when allowed"
  closureAccountingBook: AccountingBook

  "Accounting books linked to this presentation"
  accountingBooks: [AccountingBook]

  "Company this presentation belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated accounting presentation response"
type AccountingPresentationPage {
  "List of presentations for current page"
  entries: [AccountingPresentation]!

  "Total number of presentations matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching accounting presentations"
input AccountingPresentationFilters {
  "Filter by presentation name (partial match)"
  name: String

  "Search by name"
  matching: String

  "Filter by allows_closure flag"
  allowsClosure: Boolean

  "Filter by closure accounting book id"
  closureAccountingBookId: ID
}

"Available fields for sorting accounting presentations"
enum AccountingPresentationSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by allows_closure"
  ALLOWS_CLOSURE

  "Sort by closure book"
  CLOSURE_ACCOUNTING_BOOK_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for accounting presentations"
input AccountingPresentationSortInput {
  "Field to sort by"
  field: AccountingPresentationSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create accounting presentation input"
input CreateAccountingPresentationInput {
  "Presentation name"
  name: String!

  "Whether closure is allowed"
  allowsClosure: Boolean

  "Closure accounting book (required if allows_closure)"
  closureAccountingBookId: ID

  "Books to link to this presentation"
  accountingBookIds: [ID]
}

"Update accounting presentation data"
input UpdateAccountingPresentationInput {
  "Presentation name"
  name: String

  "Whether closure is allowed"
  allowsClosure: Boolean

  "Closure accounting book (required if allows_closure)"
  closureAccountingBookId: ID

  "Books to link to this presentation"
  accountingBookIds: [ID]
}

"Accounting presentation creation response"
type CreateAccountingPresentationPayload {
  "Created presentation"
  accountingPresentation: AccountingPresentation

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting presentation update response"
type UpdateAccountingPresentationPayload {
  "Updated presentation"
  accountingPresentation: AccountingPresentation

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting presentation deletion response"
type DeleteAccountingPresentationPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted presentation ID"
  deletedId: ID
}

"Response for can delete accounting presentation"
type CanDeleteAccountingPresentationPayload {
  "Whether the accounting presentation can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for AccountingPresentation"
type AccountingPresentationChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AccountingPresentation"
type AccountingPresentationTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingPresentationChange]!
}

"Filters for AccountingPresentation timeline"
input AccountingPresentationTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AccountingPresentation timeline"
enum AccountingPresentationTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AccountingPresentation timeline"
input AccountingPresentationTimelineSortInput {
  "Field to sort by"
  field: AccountingPresentationTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AccountingPresentation timeline"
type AccountingPresentationTimelinePage {
  "Timeline items for current page"
  entries: [AccountingPresentationTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Accounting book entity"
type AccountingBook {
  "Unique accounting book identifier"
  id: ID

  "Accounting book name"
  name: String

  "Company this accounting book belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated accounting book response"
type AccountingBookPage {
  "List of accounting books for current page"
  entries: [AccountingBook]!

  "Total number of accounting books matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching accounting books"
input AccountingBookFilters {
  "Filter by accounting book name (partial match)"
  name: String

  "Search by name"
  matching: String
}

"Available fields for sorting accounting books"
enum AccountingBookSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by company id"
  COMPANY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for accounting books"
input AccountingBookSortInput {
  "Field to sort by"
  field: AccountingBookSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create accounting book input"
input CreateAccountingBookInput {
  "Accounting book name"
  name: String!
}

"Update accounting book data"
input UpdateAccountingBookInput {
  "Accounting book name"
  name: String
}

"Accounting book creation response"
type CreateAccountingBookPayload {
  "Created accounting book"
  accountingBook: AccountingBook

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting book update response"
type UpdateAccountingBookPayload {
  "Updated accounting book"
  accountingBook: AccountingBook

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting book deletion response"
type DeleteAccountingBookPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted accounting book ID"
  deletedId: ID
}

"Response for can delete accounting book"
type CanDeleteAccountingBookPayload {
  "Whether the accounting book can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for AccountingBook"
type AccountingBookChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AccountingBook"
type AccountingBookTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingBookChange]!
}

"Filters for AccountingBook timeline"
input AccountingBookTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AccountingBook timeline"
enum AccountingBookTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AccountingBook timeline"
input AccountingBookTimelineSortInput {
  "Field to sort by"
  field: AccountingBookTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AccountingBook timeline"
type AccountingBookTimelinePage {
  "Timeline items for current page"
  entries: [AccountingBookTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Account nature type"
enum AccountNature {
  "Dbito (Debit)"
  D

  "Crdito (Credit)"
  C
}

"Accounting account entity"
type AccountingAccount {
  "Unique accounting account identifier"
  id: ID

  "Unique accounting account code"
  code: String

  "Accounting account name"
  name: String

  "Account nature: D (Debit) or C (Credit)"
  nature: AccountNature

  "Account margin percentage"
  margin: Decimal

  "Basis for margin calculation (100 or 1000)"
  marginBasis: Int

  "Company this accounting account belongs to"
  company: Company

  "Withholding certificates linked to this accounting account"
  withholdingCertificates: [WithholdingCertificate]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated accounting account response"
type AccountingAccountPage {
  "List of accounting accounts for current page"
  entries: [AccountingAccount]!

  "Total number of accounting accounts matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching accounting accounts"
input AccountingAccountFilters {
  "Filter by exact accounting account code"
  code: String

  "Filter by accounting account name (partial match)"
  name: String

  "Search in both code and name"
  matching: String

  "Filter by account nature (D or C)"
  nature: AccountNature

  "When true, only accounts with code length (without spaces) >= 8 are returned"
  onlyAuxiliaryAccounts: Boolean
}

"Available fields for sorting accounting accounts"
enum AccountingAccountSortField {
  "Sort by accounting account ID"
  ID

  "Sort by accounting account code"
  CODE

  "Sort by accounting account name"
  NAME

  "Sort by account nature"
  NATURE

  "Sort by account margin"
  MARGIN

  "Sort by margin basis"
  MARGIN_BASIS

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for accounting accounts"
input AccountingAccountSortInput {
  "Field to sort by"
  field: AccountingAccountSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create accounting account input"
input CreateAccountingAccountInput {
  "Unique accounting account code (1-8 numeric characters)"
  code: String!

  "Accounting account name"
  name: String!

  "Account nature: D (Debit) or C (Credit)"
  nature: AccountNature!

  "Account margin percentage"
  margin: Decimal!

  "Basis for margin calculation (100 or 1000)"
  marginBasis: Int!
}

"Update accounting account data"
input UpdateAccountingAccountInput {
  "Accounting account name"
  name: String

  "Account nature: D (Debit) or C (Credit)"
  nature: AccountNature

  "Account margin percentage"
  margin: Decimal

  "Basis for margin calculation (100 or 1000)"
  marginBasis: Int
}

"Accounting account creation response"
type CreateAccountingAccountPayload {
  "Created accounting account"
  accountingAccount: AccountingAccount

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Accounting account update response"
type UpdateAccountingAccountPayload {
  "Updated accounting account"
  accountingAccount: AccountingAccount

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Transactional bulk create response (all-or-nothing) for accounting accounts"
type CreateAccountingAccountsPayload {
  "Created accounting accounts when success is true; nil otherwise"
  accountingAccounts: [AccountingAccount]

  "Operation success status (true only if all items were created)"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors for the failure cause (first failing item)"
  errors: [FieldError]
}

"Accounting account deletion response"
type DeleteAccountingAccountPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted accounting account ID"
  deletedId: ID
}

"Response for can delete accounting account"
type CanDeleteAccountingAccountPayload {
  "Whether the accounting account can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for AccountingAccount"
type AccountingAccountChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AccountingAccount"
type AccountingAccountTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AccountingAccountChange]!
}

"Filters for AccountingAccount timeline"
input AccountingAccountTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AccountingAccount timeline"
enum AccountingAccountTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AccountingAccount timeline"
input AccountingAccountTimelineSortInput {
  "Field to sort by"
  field: AccountingAccountTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AccountingAccount timeline"
type AccountingAccountTimelinePage {
  "Timeline items for current page"
  entries: [AccountingAccountTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Fields available for sorting identification types"
enum IdentificationTypeSortField {
  "Sort by identification type ID"
  ID

  "Sort by document type code"
  CODE

  "Sort by document type name"
  NAME

  "Sort by verification digit requirement"
  HAS_VERIFICATION_DIGIT

  "Sort by minimum document length"
  MINIMUM_DOCUMENT_LENGTH

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for identification types"
input IdentificationTypeSortInput {
  "Field to sort by"
  field: IdentificationTypeSortField!

  "Sort direction (defaults to ASC)"
  direction: SortDirection
}

"Identification type entity"
type IdentificationType {
  "Unique identification type identifier"
  id: ID

  "Government-established document type code"
  code: String

  "Document type name"
  name: String

  "Whether this document type requires a verification digit"
  hasVerificationDigit: Boolean

  "Minimum digit length for this document type"
  minimumDocumentLength: Int

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated identification type response"
type IdentificationTypePage {
  "List of identification types for current page"
  entries: [IdentificationType]!

  "Total number of identification types matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching identification types"
input IdentificationTypeFilters {
  "Filter by exact identification type code"
  code: String

  "Filter by identification type name (partial match)"
  name: String

  "Search in both code and name"
  matching: String
}

"Create identification type input"
input CreateIdentificationTypeInput {
  "Government-established document type code (e.g., 13: ID Card, 31: Tax ID)"
  code: String!

  "Document type name"
  name: String!

  "Whether this document type requires a verification digit"
  hasVerificationDigit: Boolean!

  "Minimum digit length for this document type"
  minimumDocumentLength: Int!
}

"Update identification type data"
input UpdateIdentificationTypeInput {
  "Document type name"
  name: String

  "Whether this document type requires a verification digit"
  hasVerificationDigit: Boolean

  "Minimum digit length for this document type"
  minimumDocumentLength: Int
}

"Identification type creation response"
type CreateIdentificationTypePayload {
  "Created identification type"
  identificationType: IdentificationType

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Identification type update response"
type UpdateIdentificationTypePayload {
  "Updated identification type"
  identificationType: IdentificationType

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Identification type deletion response"
type DeleteIdentificationTypePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted identification type ID"
  deletedId: ID
}

"Response for can delete identification type"
type CanDeleteIdentificationTypePayload {
  "Whether the identification type can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for IdentificationType"
type IdentificationTypeChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an IdentificationType"
type IdentificationTypeTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [IdentificationTypeChange]!
}

"Filters for IdentificationType timeline"
input IdentificationTypeTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for IdentificationType timeline"
enum IdentificationTypeTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for IdentificationType timeline"
input IdentificationTypeTimelineSortInput {
  "Field to sort by"
  field: IdentificationTypeTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for IdentificationType timeline"
type IdentificationTypeTimelinePage {
  "Timeline items for current page"
  entries: [IdentificationTypeTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"AWS S3 configuration entity"
type AwsS3Config {
  "Unique identifier"
  id: ID

  "AWS secret key"
  secretKey: String

  "AWS access key"
  accessKey: String

  "Config description"
  description: String

  "AWS region"
  region: String

  "Associated company"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated aws s3 configs response"
type AwsS3ConfigPage {
  "List of AWS S3 configs for current page"
  entries: [AwsS3Config]!

  "Total number of items matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching AWS S3 configurations"
input AwsS3ConfigFilters {
  "Filter by description (partial match)"
  description: String

  "Filter by region (partial match)"
  region: String

  "Search in description, region and access_key"
  matching: String

  "Filter by company ID"
  companyId: ID
}

"Available fields for sorting aws s3 configs"
enum AwsS3ConfigSortField {
  "Sort by ID"
  ID

  "Sort by description"
  DESCRIPTION

  "Sort by region"
  REGION

  "Sort by access key"
  ACCESS_KEY

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for aws s3 configs"
input AwsS3ConfigSortInput {
  "Field to sort by"
  field: AwsS3ConfigSortField!

  "Sort direction"
  direction: SortDirection!
}

type CreateAwsS3ConfigPayload {
  awsS3Config: AwsS3Config
  success: Boolean!
  message: String
  errors: [FieldError]
}

type UpdateAwsS3ConfigPayload {
  awsS3Config: AwsS3Config
  success: Boolean!
  message: String
  errors: [FieldError]
}

type DeleteAwsS3ConfigPayload {
  success: Boolean!
  message: String
  deletedId: ID
}

"Response for can delete AWS S3 config"
type CanDeleteAwsS3ConfigPayload {
  canDelete: Boolean!
  message: String
}

"Create aws s3 config input"
input CreateAwsS3ConfigInput {
  secretKey: String!
  accessKey: String!
  description: String!
  region: String!
}

"Update aws s3 config input"
input UpdateAwsS3ConfigInput {
  secretKey: String
  accessKey: String
  description: String
  region: String
}

type AwsS3ConfigChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

type AwsS3ConfigTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AwsS3ConfigChange]!
}

input AwsS3ConfigTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

enum AwsS3ConfigTimelineSortField {
  RECORDED_AT
  ACTION
}

input AwsS3ConfigTimelineSortInput {
  field: AwsS3ConfigTimelineSortField!
  direction: SortDirection!
}

type AwsS3ConfigTimelinePage {
  entries: [AwsS3ConfigTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Currency entity"
type Currency {
  "Unique currency identifier"
  id: ID

  "ISO 4217 three-letter code (e.g., COP, USD, EUR)"
  code: String

  "Currency name"
  name: String

  "Currency symbol (e.g., $, , )"
  symbol: String

  "Decimal places (0-4)"
  minorUnits: Int

  "Whether the currency is active"
  isActive: Boolean

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated currency response"
type CurrencyPage {
  "List of currencies for current page"
  entries: [Currency]!

  "Total number of currencies matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching currencies"
input CurrencyFilters {
  "Filter by exact currency code"
  code: String

  "Filter by currency name (partial match)"
  name: String

  "Search in both code and name"
  matching: String

  "Filter by active status"
  isActive: Boolean
}

"Available fields for sorting currencies"
enum CurrencySortField {
  "Sort by currency ID"
  ID

  "Sort by currency code"
  CODE

  "Sort by currency name"
  NAME

  "Sort by symbol"
  SYMBOL

  "Sort by minor_units"
  MINOR_UNITS

  "Sort by active flag"
  IS_ACTIVE

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for currencies"
input CurrencySortInput {
  "Field to sort by"
  field: CurrencySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create currency input"
input CreateCurrencyInput {
  "ISO 4217 three-letter code"
  code: String!

  "Currency name"
  name: String!

  "Currency symbol"
  symbol: String

  "Decimal places (0-4)"
  minorUnits: Int

  "Active flag"
  isActive: Boolean
}

"Update currency data"
input UpdateCurrencyInput {
  "Currency name"
  name: String

  "Currency symbol"
  symbol: String

  "Decimal places (0-4)"
  minorUnits: Int

  "Active flag"
  isActive: Boolean
}

"Currency creation response"
type CreateCurrencyPayload {
  "Created currency"
  currency: Currency

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Currency update response"
type UpdateCurrencyPayload {
  "Updated currency"
  currency: Currency

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Currency deletion response"
type DeleteCurrencyPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted currency ID"
  deletedId: ID
}

"Humanized field-level change for Currency"
type CurrencyChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Currency"
type CurrencyTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CurrencyChange]!
}

"Filters for Currency timeline"
input CurrencyTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Currency timeline"
enum CurrencyTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Currency timeline"
input CurrencyTimelineSortInput {
  "Field to sort by"
  field: CurrencyTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Currency timeline"
type CurrencyTimelinePage {
  "Timeline items for current page"
  entries: [CurrencyTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Email entity"
type Email {
  "Unique email identifier"
  id: ID

  "Description\/label for this email"
  description: String

  "Email address"
  email: String

  "Marks email as corporate"
  isCorporate: Boolean

  "Receives electronic invoices"
  isElectronicInvoiceRecipient: Boolean

  "Associated company"
  company: Company

  "SMTP server"
  smtp: Smtp

  "Associated accounting entity"
  accountingEntity: AccountingEntity

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated emails response"
type EmailPage {
  "List of emails for current page"
  entries: [Email]!

  "Total number of emails matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching emails"
input EmailFilters {
  "Filter by description (partial match)"
  description: String

  "Filter by email address (partial match)"
  email: String

  "Search in email and description"
  matching: String

  "Filter by corporate flag"
  isCorporate: Boolean

  "Filter by EDI flag"
  isElectronicInvoiceRecipient: Boolean

  "Filter by accounting entity ID"
  accountingEntityId: ID

  "Filter by SMTP server ID"
  smtpId: ID
}

"Available fields for sorting emails"
enum EmailSortField {
  "Sort by ID"
  ID

  "Sort by description"
  DESCRIPTION

  "Sort by email address"
  EMAIL

  "Sort by corporate flag"
  IS_CORPORATE

  "Sort by EDI flag"
  IS_ELECTRONIC_INVOICE_RECIPIENT

  "Sort by accounting entity ID"
  ACCOUNTING_ENTITY_ID

  "Sort by SMTP server ID"
  SMTP_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for emails"
input EmailSortInput {
  "Field to sort by"
  field: EmailSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create email input"
input CreateEmailInput {
  "Email description\/label"
  description: String!

  "Email address"
  email: String!

  "Password for this email account"
  password: String

  "Marks email as corporate"
  isCorporate: Boolean

  "Receives electronic invoices"
  isElectronicInvoiceRecipient: Boolean

  "Associated accounting entity ID"
  accountingEntityId: ID!

  "SMTP server ID"
  smtpId: ID
}

"Update email input (partial)"
input UpdateEmailInput {
  "Email description\/label"
  description: String

  "Email address"
  email: String

  "Password for this email account"
  password: String

  "Marks email as corporate"
  isCorporate: Boolean

  "Receives electronic invoices"
  isElectronicInvoiceRecipient: Boolean

  "Associated accounting entity ID"
  accountingEntityId: ID

  "SMTP server ID"
  smtpId: ID
}

"Email creation response"
type CreateEmailPayload {
  "Created email"
  email: Email

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Email update response"
type UpdateEmailPayload {
  "Updated email"
  email: Email

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Email deletion response"
type DeleteEmailPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted email ID"
  deletedId: ID
}

"Response for can delete email"
type CanDeleteEmailPayload {
  "Whether the email can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Email"
type EmailChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an Email"
type EmailTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [EmailChange]!
}

"Filters for Email timeline"
input EmailTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Email timeline"
enum EmailTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Email timeline"
input EmailTimelineSortInput {
  "Field to sort by"
  field: EmailTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Email timeline"
type EmailTimelinePage {
  "Timeline items for current page"
  entries: [EmailTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"SMTP server entity"
type Smtp {
  "Unique SMTP identifier"
  id: ID

  "SMTP display name"
  name: String

  "SMTP host (hostname or IP)"
  host: String

  "SMTP port"
  port: Int

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated SMTP response"
type SmtpPage {
  "List of SMTP servers for current page"
  entries: [Smtp]!

  "Total number of SMTP servers matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching SMTP servers"
input SmtpFilters {
  "Filter by SMTP name (partial match)"
  name: String

  "Filter by host (partial match)"
  host: String

  "Search in name and host"
  matching: String
}

"Available fields for sorting SMTP servers"
enum SmtpSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by host"
  HOST

  "Sort by port"
  PORT

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for SMTP servers"
input SmtpSortInput {
  "Field to sort by"
  field: SmtpSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create SMTP input"
input CreateSmtpInput {
  "SMTP name"
  name: String!

  "SMTP host"
  host: String!

  "SMTP port"
  port: Int!
}

"Update SMTP input (partial)"
input UpdateSmtpInput {
  "SMTP name"
  name: String

  "SMTP host"
  host: String

  "SMTP port"
  port: Int
}

"SMTP creation response"
type CreateSmtpPayload {
  "Created SMTP server"
  smtp: Smtp

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"SMTP update response"
type UpdateSmtpPayload {
  "Updated SMTP server"
  smtp: Smtp

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"SMTP deletion response"
type DeleteSmtpPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted SMTP ID"
  deletedId: ID
}

"Response for can delete SMTP"
type CanDeleteSmtpPayload {
  "Whether the SMTP can be deleted"
  canDelete: Boolean!

  "Reason if deletion is blocked"
  message: String
}

"Humanized field-level change for SMTP"
type SmtpChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an SMTP"
type SmtpTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [SmtpChange]!
}

"Filters for SMTP timeline"
input SmtpTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for SMTP timeline"
enum SmtpTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for SMTP timeline"
input SmtpTimelineSortInput {
  "Field to sort by"
  field: SmtpTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for SMTP timeline"
type SmtpTimelinePage {
  "Timeline items for current page"
  entries: [SmtpTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Authorization Sequence entity"
type AuthorizationSequence {
  "Unique authorization sequence identifier"
  id: ID!

  "Authorization number issued by DIAN"
  number: String

  "Authorization validity start date"
  startDate: Date

  "Authorization validity end date"
  endDate: Date

  "Invoice prefix"
  prefix: String

  "Starting invoice number in range"
  startRange: Int

  "Ending invoice number in range"
  endRange: Int

  "Auto-computed description"
  description: String

  "Active status"
  isActive: Boolean

  "Authorization mode (A=Autoriza, H=Habilita)"
  mode: AuthorizationMode

  "DIAN technical key"
  technicalKey: String

  "Reference code"
  reference: String

  "Current invoice number in use"
  currentInvoiceNumber: Int

  "Owning company"
  company: Company

  "Associated cost center"
  costCenter: CostCenter

  "Authorization sequence type (FE, PE, DS)"
  authorizationSequenceType: AuthorizationSequenceType

  "Next authorization sequence in chain"
  nextAuthorizationSequence: AuthorizationSequence

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Authorization mode: A = Autoriza, H = Habilita"
enum AuthorizationMode {
  "Autoriza"
  A

  "Habilita"
  H
}

"Paginated authorization sequences response"
type AuthorizationSequencePage {
  "List of authorization sequences for current page"
  entries: [AuthorizationSequence]!

  "Current page number"
  pageNumber: Int!

  "Number of items per page"
  pageSize: Int!

  "Total number of items matching filter"
  totalEntries: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching authorization sequences"
input AuthorizationSequenceFilters {
  "Filter by number (partial match)"
  number: String

  "Filter by description (partial match)"
  description: String

  "Filter by prefix (exact match)"
  prefix: String

  "Filter by active status"
  isActive: Boolean

  "Filter by mode"
  mode: AuthorizationMode

  "Filter by technical key (partial match)"
  technicalKey: String

  "Filter by reference (partial match)"
  reference: String

  "Search in number, description, technical_key, reference and prefix"
  matching: String

  "Filter by cost center ID"
  costCenterId: ID

  "Filter by type ID"
  authorizationSequenceTypeId: ID

  "Filter by next sequence ID"
  nextAuthorizationSequenceId: ID

  "Filter start_date >= value"
  startDateFrom: Date

  "Filter start_date <= value"
  startDateTo: Date

  "Filter end_date >= value"
  endDateFrom: Date

  "Filter end_date <= value"
  endDateTo: Date

  "Filter start_range >= value"
  startRangeMin: Int

  "Filter start_range <= value"
  startRangeMax: Int

  "Filter end_range >= value"
  endRangeMin: Int

  "Filter end_range <= value"
  endRangeMax: Int

  "Filter current_invoice_number >= value"
  currentInvoiceNumberMin: Int

  "Filter current_invoice_number <= value"
  currentInvoiceNumberMax: Int
}

"Sort configuration for authorization sequences"
input AuthorizationSequenceSortInput {
  "Field to sort by"
  field: AuthorizationSequenceSortField!

  "Sort direction"
  direction: SortDirection
}

"Available fields for sorting authorization sequences"
enum AuthorizationSequenceSortField {
  "Sort by ID"
  ID

  "Sort by number"
  NUMBER

  "Sort by start date"
  START_DATE

  "Sort by end date"
  END_DATE

  "Sort by prefix"
  PREFIX

  "Sort by start range"
  START_RANGE

  "Sort by end range"
  END_RANGE

  "Sort by description"
  DESCRIPTION

  "Sort by active status"
  IS_ACTIVE

  "Sort by mode"
  MODE

  "Sort by technical key"
  TECHNICAL_KEY

  "Sort by reference"
  REFERENCE

  "Sort by current invoice number"
  CURRENT_INVOICE_NUMBER

  "Sort by next sequence ID"
  NEXT_AUTHORIZATION_SEQUENCE_ID

  "Sort by company ID"
  COMPANY_ID

  "Sort by cost center ID"
  COST_CENTER_ID

  "Sort by type ID"
  AUTHORIZATION_SEQUENCE_TYPE_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

input CreateAuthorizationSequenceInput {
  number: String!
  startDate: Date!
  endDate: Date!
  prefix: String!
  startRange: Int!
  endRange: Int!
  isActive: Boolean
  mode: AuthorizationMode!
  technicalKey: String
  reference: String!
  currentInvoiceNumber: Int
  costCenterId: ID!
  authorizationSequenceTypeId: ID!
  nextAuthorizationSequenceId: ID
}

input UpdateAuthorizationSequenceInput {
  number: String
  startDate: Date
  endDate: Date
  prefix: String
  startRange: Int
  endRange: Int
  isActive: Boolean
  mode: AuthorizationMode
  technicalKey: String
  reference: String
  currentInvoiceNumber: Int
  nextAuthorizationSequenceId: ID
}

type CreateAuthorizationSequencePayload {
  success: Boolean!
  message: String!
  authorizationSequence: AuthorizationSequence
  errors: [FieldError]
}

type UpdateAuthorizationSequencePayload {
  success: Boolean!
  message: String!
  authorizationSequence: AuthorizationSequence
  errors: [FieldError]
}

type DeleteAuthorizationSequencePayload {
  success: Boolean!
  message: String!
  deletedId: ID
  errors: [FieldError]
}

"Response for can delete authorization sequence"
type CanDeleteAuthorizationSequencePayload {
  canDelete: Boolean!
  message: String
}

"Humanized field-level change for AuthorizationSequence"
type AuthorizationSequenceChange {
  field: String!
  op: AuditOp!
  old: String
  new: String
}

"Timeline item for an AuthorizationSequence"
type AuthorizationSequenceTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AuthorizationSequenceChange]!
}

"Filters for AuthorizationSequence timeline"
input AuthorizationSequenceTimelineFilters {
  action: AuditAction
  from: IsoDatetime
  to: IsoDatetime
}

"Sort fields for AuthorizationSequence timeline"
enum AuthorizationSequenceTimelineSortField {
  RECORDED_AT
  ACTION
}

"Sort configuration for AuthorizationSequence timeline"
input AuthorizationSequenceTimelineSortInput {
  field: AuthorizationSequenceTimelineSortField!
  direction: SortDirection!
}

"Paginated response for AuthorizationSequence timeline"
type AuthorizationSequenceTimelinePage {
  entries: [AuthorizationSequenceTimelineItem]!
  totalEntries: Int!
  pageSize: Int!
  pageNumber: Int!
  totalPages: Int!
}

"Authorization Sequence Type entity"
type AuthorizationSequenceType {
  "Unique authorization sequence type identifier"
  id: ID!

  "Authorization sequence type name"
  name: String

  "Active status"
  isActive: Boolean

  "Prefix code (FE, PE, DS)"
  prefix: AuthorizationPrefix

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated authorization sequence types response"
type AuthorizationSequenceTypePage {
  "List of authorization sequence types for current page"
  entries: [AuthorizationSequenceType]!

  "Current page number"
  pageNumber: Int!

  "Number of items per page"
  pageSize: Int!

  "Total number of items matching filter"
  totalEntries: Int!

  "Total number of pages"
  totalPages: Int!
}

input AuthorizationSequenceTypeFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by active state"
  isActive: Boolean

  "Filter by prefix (exact match)"
  prefix: AuthorizationPrefix
}

input AuthorizationSequenceTypeSortInput {
  field: AuthorizationSequenceTypeSortField!
  direction: SortDirection
}

"Available fields for sorting authorization sequence types"
enum AuthorizationSequenceTypeSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by active status"
  IS_ACTIVE

  "Sort by prefix"
  PREFIX

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

input CreateAuthorizationSequenceTypeInput {
  name: String!
  isActive: Boolean
  prefix: AuthorizationPrefix!
}

input UpdateAuthorizationSequenceTypeInput {
  name: String
  isActive: Boolean
  prefix: AuthorizationPrefix
}

type CreateAuthorizationSequenceTypePayload {
  success: Boolean!
  message: String!
  authorizationSequenceType: AuthorizationSequenceType
  errors: [FieldError]
}

type UpdateAuthorizationSequenceTypePayload {
  success: Boolean!
  message: String!
  authorizationSequenceType: AuthorizationSequenceType
  errors: [FieldError]
}

type DeleteAuthorizationSequenceTypePayload {
  success: Boolean!
  message: String!
  deletedId: ID
  errors: [FieldError]
}

"Response for can delete authorization sequence type"
type CanDeleteAuthorizationSequenceTypePayload {
  "Whether the authorization sequence type can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Authorization prefix type"
enum AuthorizationPrefix {
  "FACTURA ELECTRNICA"
  FE

  "POS ELECTRNICO"
  PE

  "DOCUMENTO DE SOPORTE"
  DS
}

"Humanized field-level change for AuthorizationSequenceType"
type AuthorizationSequenceTypeChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for an AuthorizationSequenceType"
type AuthorizationSequenceTypeTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [AuthorizationSequenceTypeChange]!
}

"Filters for AuthorizationSequenceType timeline"
input AuthorizationSequenceTypeTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for AuthorizationSequenceType timeline"
enum AuthorizationSequenceTypeTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for AuthorizationSequenceType timeline"
input AuthorizationSequenceTypeTimelineSortInput {
  "Field to sort by"
  field: AuthorizationSequenceTypeTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for AuthorizationSequenceType timeline"
type AuthorizationSequenceTypeTimelinePage {
  "Timeline items for current page"
  entries: [AuthorizationSequenceTypeTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Document sequence monthly entity"
type DocumentSequenceMonthly {
  "Unique identifier"
  id: ID

  "Year"
  year: Int

  "Month (1-12)"
  month: Int

  "Current sequence for the period"
  sequence: Int

  "Associated document sequence"
  documentSequence: DocumentSequence

  "Associated cost center"
  costCenter: CostCenter

  "Company this monthly row belongs to"
  company: Company

  "User who created this record"
  createdBy: Account
}

"Paginated document sequence monthly response"
type DocumentSequenceMonthlyPage {
  "List of monthly rows"
  entries: [DocumentSequenceMonthly]!

  "Total number of rows matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching document sequence monthly"
input DocumentSequenceMonthlyFilters {
  "Filter by document_sequence_id"
  documentSequenceId: ID

  "Filter by cost_center_id"
  costCenterId: ID

  "Filter by year"
  year: Int

  "Filter by month"
  month: Int
}

"Available fields for sorting document sequence monthly"
enum DocumentSequenceMonthlySortField {
  "Sort by ID"
  ID

  "Sort by document_sequence_id"
  DOCUMENT_SEQUENCE_ID

  "Sort by cost_center_id"
  COST_CENTER_ID

  "Sort by year"
  YEAR

  "Sort by month"
  MONTH

  "Sort by sequence"
  SEQUENCE

  "Sort by inserted_at"
  INSERTED_AT

  "Sort by updated_at"
  UPDATED_AT
}

"Sort configuration for document sequence monthly"
input DocumentSequenceMonthlySortInput {
  "Field to sort by"
  field: DocumentSequenceMonthlySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create document sequence monthly input"
input CreateDocumentSequenceMonthlyInput {
  "Associated document sequence ID"
  documentSequenceId: ID!

  "Associated cost center ID"
  costCenterId: ID!

  "Year"
  year: Int!

  "Month (1-12)"
  month: Int!

  "Initial sequence value"
  sequence: Int
}

"Update document sequence monthly input"
input UpdateDocumentSequenceMonthlyInput {
  "Associated document sequence ID"
  documentSequenceId: ID

  "Associated cost center ID"
  costCenterId: ID

  "Year"
  year: Int

  "Month (1-12)"
  month: Int

  "Sequence value"
  sequence: Int
}

"Create document sequence monthly response"
type CreateDocumentSequenceMonthlyPayload {
  "Operation success"
  success: Boolean!

  "Response message"
  message: String

  "Created entity"
  documentSequenceMonthly: DocumentSequenceMonthly

  "Validation errors"
  errors: [FieldError]
}

"Update document sequence monthly response"
type UpdateDocumentSequenceMonthlyPayload {
  "Operation success"
  success: Boolean!

  "Response message"
  message: String

  "Updated entity"
  documentSequenceMonthly: DocumentSequenceMonthly

  "Validation errors"
  errors: [FieldError]
}

"Delete document sequence monthly response"
type DeleteDocumentSequenceMonthlyPayload {
  "Operation success"
  success: Boolean!

  "Response message"
  message: String

  "Deleted ID"
  deletedId: ID
}

"Document sequence type enum (exposes letter to clients)"
enum DocumentSequenceType {
  "Yearly (Y)"
  Y

  "Monthly (M)"
  M

  "Simple (S)"
  S
}

"Document sequence entity"
type DocumentSequence {
  "Unique document sequence identifier"
  id: ID

  "Document sequence name"
  name: String

  "Sequence type"
  type: DocumentSequenceType

  "Human-friendly type name (informative)"
  typeName: String

  "Whether sequence is system-defined"
  system: Boolean

  "Associated module"
  module: Module

  "Company this document sequence belongs to"
  company: Company

  "User who created this record"
  createdBy: Account
}

"Paginated document sequence response"
type DocumentSequencePage {
  "List of document sequences"
  entries: [DocumentSequence]!

  "Total number of document sequences matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching document sequences"
input DocumentSequenceFilters {
  "Filter by name (partial match)"
  name: String

  "Filter by type"
  type: DocumentSequenceType

  "Filter by system flag"
  system: Boolean

  "Filter by module ID"
  moduleId: ID
}

"Available fields for sorting document sequences"
enum DocumentSequenceSortField {
  "Sort by ID"
  ID

  "Sort by name"
  NAME

  "Sort by type"
  TYPE

  "Sort by module ID"
  MODULE_ID
}

"Sort configuration for document sequences"
input DocumentSequenceSortInput {
  "Field to sort by"
  field: DocumentSequenceSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create document sequence input"
input CreateDocumentSequenceInput {
  "Document sequence name"
  name: String!

  "Sequence type"
  type: DocumentSequenceType!

  "System flag"
  system: Boolean

  "Associated module ID"
  moduleId: ID!
}

"Update document sequence input"
input UpdateDocumentSequenceInput {
  "Document sequence name"
  name: String

  "Sequence type"
  type: DocumentSequenceType

  "System flag"
  system: Boolean

  "Associated module ID"
  moduleId: ID
}

"Create document sequence response"
type CreateDocumentSequencePayload {
  "Operation success"
  success: Boolean!

  "Response message"
  message: String

  "Created document sequence"
  documentSequence: DocumentSequence

  "Validation errors"
  errors: [FieldError]
}

"Update document sequence response"
type UpdateDocumentSequencePayload {
  "Operation success"
  success: Boolean!

  "Response message"
  message: String

  "Updated document sequence"
  documentSequence: DocumentSequence

  "Validation errors"
  errors: [FieldError]
}

"Delete document sequence response"
type DeleteDocumentSequencePayload {
  "Operation success"
  success: Boolean!

  "Response message"
  message: String

  "Deleted document sequence ID"
  deletedId: ID
}

type CanDeleteDocumentSequencePayload {
  canDelete: Boolean!
  message: String
}

"Humanized field-level change for DocumentSequence"
type DocumentSequenceChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a DocumentSequence"
type DocumentSequenceTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [DocumentSequenceChange]!
}

"Filters for DocumentSequence timeline"
input DocumentSequenceTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for DocumentSequence timeline"
enum DocumentSequenceTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for DocumentSequence timeline"
input DocumentSequenceTimelineSortInput {
  "Field to sort by"
  field: DocumentSequenceTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for DocumentSequence timeline"
type DocumentSequenceTimelinePage {
  "Timeline items for current page"
  entries: [DocumentSequenceTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"ProcessType entity"
type ProcessType {
  "Unique process type identifier"
  id: ID

  "Process type name"
  name: String

  "Company this process type belongs to"
  company: Company

  "Module this process type belongs to"
  module: Module

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated process type response"
type ProcessTypePage {
  "List of process types for current page"
  entries: [ProcessType]!

  "Total number of process types matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching process types"
input ProcessTypeFilters {
  "Filter by process type name (partial match)"
  name: String

  "Filter by module identifier"
  moduleId: ID

  "Search in name"
  matching: String
}

"Available fields for sorting process types"
enum ProcessTypeSortField {
  "Sort by process type ID"
  ID

  "Sort by process type name"
  NAME

  "Sort by module ID"
  MODULE_ID

  "Sort by company ID"
  COMPANY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for process types"
input ProcessTypeSortInput {
  "Field to sort by"
  field: ProcessTypeSortField!

  "Sort direction"
  direction: SortDirection!
}

"Input for creating a new process type"
input CreateProcessTypeInput {
  "Process type name (required)"
  name: String!

  "Module identifier (required)"
  moduleId: ID!
}

"Input for updating an existing process type"
input UpdateProcessTypeInput {
  "Process type name"
  name: String

  "Module identifier"
  moduleId: ID
}

"Payload for process type creation mutation"
type CreateProcessTypePayload {
  "The created process type"
  processType: ProcessType

  "Whether the creation was successful"
  success: Boolean

  "Success or error message"
  message: String

  "List of validation errors"
  errors: [FieldError]
}

"Payload for process type update mutation"
type UpdateProcessTypePayload {
  "The updated process type"
  processType: ProcessType

  "Whether the update was successful"
  success: Boolean

  "Success or error message"
  message: String

  "List of validation errors"
  errors: [FieldError]
}

"Payload for process type deletion mutation"
type DeleteProcessTypePayload {
  "Whether the deletion was successful"
  success: Boolean

  "Success or error message"
  message: String

  "ID of the deleted process type"
  deletedId: ID
}

"Response for can delete process type"
type CanDeleteProcessTypePayload {
  "Whether the process type can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for ProcessType"
type ProcessTypeChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a ProcessType"
type ProcessTypeTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ProcessTypeChange]!
}

"Filters for ProcessType timeline"
input ProcessTypeTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for ProcessType timeline"
enum ProcessTypeTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for ProcessType timeline"
input ProcessTypeTimelineSortInput {
  "Field to sort by"
  field: ProcessTypeTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for ProcessType timeline"
type ProcessTypeTimelinePage {
  "Timeline items for current page"
  entries: [ProcessTypeTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Module entity"
type Module {
  "Unique module identifier"
  id: ID

  "Module code (3 characters)"
  code: String

  "Module name"
  name: String

  "Module abbreviation"
  abbreviation: String

  "Whether the module is active"
  isActive: Boolean

  "Display order (0 or greater)"
  displayOrder: Int

  "Company this module belongs to"
  company: Company

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated module response"
type ModulePage {
  "List of modules for current page"
  entries: [Module]!

  "Total number of modules matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching modules"
input ModuleFilters {
  "Filter by module code (partial match)"
  code: String

  "Filter by module name (partial match)"
  name: String

  "Filter by module abbreviation (partial match)"
  abbreviation: String

  "Search in code, name and abbreviation"
  matching: String

  "Filter by active\/inactive status"
  isActive: Boolean

  "Filter by display order (exact match)"
  displayOrder: Int
}

"Available fields for sorting modules"
enum ModuleSortField {
  "Sort by module ID"
  ID

  "Sort by module code"
  CODE

  "Sort by module name"
  NAME

  "Sort by module abbreviation"
  ABBREVIATION

  "Sort by company ID"
  COMPANY_ID

  "Sort by active\/inactive status"
  IS_ACTIVE

  "Sort by display order"
  DISPLAY_ORDER

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for modules"
input ModuleSortInput {
  "Field to sort by"
  field: ModuleSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create module input"
input CreateModuleInput {
  "Module code (exactly 3 uppercase letters)"
  code: String!

  "Module name"
  name: String!

  "Module abbreviation"
  abbreviation: String!

  "Whether the module is active (defaults to true)"
  isActive: Boolean

  "Display order (defaults to 0)"
  displayOrder: Int
}

"Update module data"
input UpdateModuleInput {
  "Module code (exactly 3 uppercase letters)"
  code: String

  "Module name"
  name: String

  "Module abbreviation"
  abbreviation: String

  "Whether the module is active"
  isActive: Boolean

  "Display order"
  displayOrder: Int
}

"Create module response"
type CreateModulePayload {
  "Indicates if the operation was successful"
  success: Boolean!

  "Operation result message"
  message: String!

  "The created module"
  module: Module

  "List of field errors, if any"
  errors: [FieldError]
}

"Update module response"
type UpdateModulePayload {
  "Indicates if the operation was successful"
  success: Boolean!

  "Operation result message"
  message: String!

  "The updated module"
  module: Module

  "List of field errors, if any"
  errors: [FieldError]
}

"Delete module response"
type DeleteModulePayload {
  "Indicates if the operation was successful"
  success: Boolean!

  "Operation result message"
  message: String!

  "ID of the deleted module"
  deletedId: ID
}

"Response for can delete module"
type CanDeleteModulePayload {
  "Whether the module can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Module"
type ModuleChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Module"
type ModuleTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [ModuleChange]!
}

"Filters for Module timeline"
input ModuleTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Module timeline"
enum ModuleTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Module timeline"
input ModuleTimelineSortInput {
  "Field to sort by"
  field: ModuleTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Module timeline"
type ModuleTimelinePage {
  "Timeline items for current page"
  entries: [ModuleTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Cost center state enum"
enum CostCenterStatus {
  "Activo"
  ACTIVE

  "Inactivo"
  INACTIVE

  "Solo Lectura"
  READ_ONLY
}

"Date control type enum"
enum DateControlType {
  "Fecha de transaccin controlada por cuadre de caja"
  CONTROLLED_BY_CASH_REGISTER

  "Fecha del servidor"
  SERVER_DATE

  "Fecha del equipo local"
  LOCAL_DATE

  "Fecha abierta a manipulacin"
  OPEN_DATE
}

"Cost center entity"
type CostCenter {
  "Unique cost center identifier"
  id: ID

  "Cost center name"
  name: String

  "Cost center trade name"
  tradeName: String

  "Cost center status"
  status: CostCenterStatus

  "Cost center address"
  address: String

  "Primary phone number"
  primaryPhone: String

  "Secondary phone number"
  secondaryPhone: String

  "Primary cell phone number"
  primaryCellPhone: String

  "Secondary cell phone number"
  secondaryCellPhone: String

  "Date control type"
  dateControlType: DateControlType

  "Whether cost center is taxable"
  isTaxable: Boolean

  "Whether price list includes tax"
  priceListIncludeTax: Boolean

  "Whether invoice price includes tax"
  invoicePriceIncludeTax: Boolean

  "Whether to show change window on cash"
  showChangeWindowOnCash: Boolean

  "Whether to allow repeat items on sales"
  allowRepeatItemsOnSales: Boolean

  "Whether requires confirmation to print copies"
  requiresConfirmationToPrintCopies: Boolean

  "Whether cost center allows buying"
  allowBuy: Boolean

  "Whether cost center allows selling"
  allowSell: Boolean

  "Whether tax goes to cost"
  taxToCost: Boolean

  "Default invoice observation"
  defaultInvoiceObservation: String

  "Invoice footer text"
  invoiceFooter: String

  "Remission footer text"
  remissionFooter: String

  "Number of invoice copies to print"
  invoiceCopiesToPrint: Int

  "Cost center short name"
  shortName: String

  "Company this cost center belongs to"
  company: Company

  "Associated country"
  country: Country

  "Associated department"
  department: Department

  "Associated city"
  city: City

  "Associated company location"
  companyLocation: CompanyLocation

  "Default authorization sequence for FE credit"
  feCreditDefaultAuthorizationSequence: AuthorizationSequence

  "Default authorization sequence for FE cash"
  feCashDefaultAuthorizationSequence: AuthorizationSequence

  "Default authorization sequence for POS"
  peDefaultAuthorizationSequence: AuthorizationSequence

  "Default authorization sequence for Remissions (DS)"
  dsDefaultAuthorizationSequence: AuthorizationSequence

  "Associated sellers"
  sellers: [Seller]

  "Franchise configurations for this cost center"
  franchisesByCostCenter: [FranchiseByCostCenter]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated cost center response"
type CostCenterPage {
  "List of cost centers for current page"
  entries: [CostCenter]!

  "Total number of cost centers matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching cost centers"
input CostCenterFilters {
  "Filter by cost center name (partial match)"
  name: String

  "Filter by trade name (partial match)"
  tradeName: String

  "Filter by short name (partial match)"
  shortName: String

  "Filter by status"
  status: CostCenterStatus

  "Filter by date control type"
  dateControlType: DateControlType

  "Filter by taxable status"
  isTaxable: Boolean

  "Filter by allow buy permission"
  allowBuy: Boolean

  "Filter by allow sell permission"
  allowSell: Boolean

  "Filter by country ID"
  countryId: ID

  "Filter by department ID"
  departmentId: ID

  "Filter by city ID"
  cityId: ID

  "Filter by company location ID"
  companyLocationId: ID

  "Search in name, trade name, short name and address"
  matching: String
}

"Available fields for sorting cost centers"
enum CostCenterSortField {
  "Sort by cost center ID"
  ID

  "Sort by cost center name"
  NAME

  "Sort by trade name"
  TRADE_NAME

  "Sort by short name"
  SHORT_NAME

  "Sort by status"
  STATUS

  "Sort by taxable status"
  IS_TAXABLE

  "Sort by allow buy permission"
  ALLOW_BUY

  "Sort by allow sell permission"
  ALLOW_SELL

  "Sort by country ID"
  COUNTRY_ID

  "Sort by department ID"
  DEPARTMENT_ID

  "Sort by city ID"
  CITY_ID

  "Sort by company location ID"
  COMPANY_LOCATION_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for cost centers"
input CostCenterSortInput {
  "Field to sort by"
  field: CostCenterSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create cost center input"
input CreateCostCenterInput {
  "Cost center name"
  name: String!

  "Cost center trade name"
  tradeName: String

  "Cost center status"
  status: CostCenterStatus

  "Cost center address"
  address: String

  "Primary phone number"
  primaryPhone: String

  "Secondary phone number"
  secondaryPhone: String

  "Primary cell phone number"
  primaryCellPhone: String

  "Secondary cell phone number"
  secondaryCellPhone: String

  "Date control type"
  dateControlType: DateControlType!

  "Whether cost center is taxable"
  isTaxable: Boolean

  "Whether price list includes tax"
  priceListIncludeTax: Boolean

  "Whether invoice price includes tax"
  invoicePriceIncludeTax: Boolean

  "Whether to show change window on cash"
  showChangeWindowOnCash: Boolean

  "Whether to allow repeat items on sales"
  allowRepeatItemsOnSales: Boolean

  "Whether requires confirmation to print copies"
  requiresConfirmationToPrintCopies: Boolean

  "Whether cost center allows buying"
  allowBuy: Boolean

  "Whether cost center allows selling"
  allowSell: Boolean

  "Whether tax goes to cost"
  taxToCost: Boolean

  "Default invoice observation"
  defaultInvoiceObservation: String

  "Invoice footer text"
  invoiceFooter: String

  "Remission footer text"
  remissionFooter: String

  "Number of invoice copies to print"
  invoiceCopiesToPrint: Int

  "Cost center short name"
  shortName: String!

  "Associated country ID"
  countryId: ID!

  "Associated department ID"
  departmentId: ID!

  "Associated city ID"
  cityId: ID!

  "Associated company location ID"
  companyLocationId: ID!

  "Default authorization sequence ID for FE credit"
  feCreditDefaultAuthorizationSequenceId: ID

  "Default authorization sequence ID for FE cash"
  feCashDefaultAuthorizationSequenceId: ID

  "Default authorization sequence ID for POS"
  peDefaultAuthorizationSequenceId: ID

  "Default authorization sequence ID for Remissions (DS)"
  dsDefaultAuthorizationSequenceId: ID
}

"Update cost center data"
input UpdateCostCenterInput {
  "Cost center name"
  name: String

  "Cost center trade name"
  tradeName: String

  "Cost center status"
  status: CostCenterStatus

  "Cost center address"
  address: String

  "Primary phone number"
  primaryPhone: String

  "Secondary phone number"
  secondaryPhone: String

  "Primary cell phone number"
  primaryCellPhone: String

  "Secondary cell phone number"
  secondaryCellPhone: String

  "Date control type"
  dateControlType: DateControlType

  "Whether cost center is taxable"
  isTaxable: Boolean

  "Whether price list includes tax"
  priceListIncludeTax: Boolean

  "Whether invoice price includes tax"
  invoicePriceIncludeTax: Boolean

  "Whether to show change window on cash"
  showChangeWindowOnCash: Boolean

  "Whether to allow repeat items on sales"
  allowRepeatItemsOnSales: Boolean

  "Whether requires confirmation to print copies"
  requiresConfirmationToPrintCopies: Boolean

  "Whether cost center allows buying"
  allowBuy: Boolean

  "Whether cost center allows selling"
  allowSell: Boolean

  "Whether tax goes to cost"
  taxToCost: Boolean

  "Default invoice observation"
  defaultInvoiceObservation: String

  "Invoice footer text"
  invoiceFooter: String

  "Remission footer text"
  remissionFooter: String

  "Number of invoice copies to print"
  invoiceCopiesToPrint: Int

  "Cost center short name"
  shortName: String

  "Associated country ID"
  countryId: ID

  "Associated department ID"
  departmentId: ID

  "Associated city ID"
  cityId: ID

  "Associated company location ID"
  companyLocationId: ID

  "Default authorization sequence ID for FE credit"
  feCreditDefaultAuthorizationSequenceId: ID

  "Default authorization sequence ID for FE cash"
  feCashDefaultAuthorizationSequenceId: ID

  "Default authorization sequence ID for POS"
  peDefaultAuthorizationSequenceId: ID

  "Default authorization sequence ID for Remissions (DS)"
  dsDefaultAuthorizationSequenceId: ID
}

"Cost center creation response"
type CreateCostCenterPayload {
  "Created cost center"
  costCenter: CostCenter

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Cost center update response"
type UpdateCostCenterPayload {
  "Updated cost center"
  costCenter: CostCenter

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Cost center deletion response"
type DeleteCostCenterPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted cost center ID"
  deletedId: ID
}

"Response for can delete cost center"
type CanDeleteCostCenterPayload {
  "Whether the cost center can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Cost Center"
type CostCenterChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Cost Center"
type CostCenterTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CostCenterChange]!
}

"Filters for Cost Center timeline"
input CostCenterTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Cost Center timeline"
enum CostCenterTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Cost Center timeline"
input CostCenterTimelineSortInput {
  "Field to sort by"
  field: CostCenterTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Cost Center timeline"
type CostCenterTimelinePage {
  "Timeline items for current page"
  entries: [CostCenterTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Company location entity"
type CompanyLocation {
  "Unique company location identifier"
  id: ID

  "Company location name"
  name: String

  "Associated company"
  company: Company

  "Storages under this company location"
  storages: [Storage]

  "Cost centers under this company location"
  costCenters: [CostCenter]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated company location response"
type CompanyLocationPage {
  "List of company locations for current page"
  entries: [CompanyLocation]!

  "Total number of company locations matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching company locations"
input CompanyLocationFilters {
  "Filter by company location name (partial match)"
  name: String

  "Search in name"
  matching: String
}

"Available fields for sorting company locations"
enum CompanyLocationSortField {
  "Sort by company location ID"
  ID

  "Sort by company location name"
  NAME

  "Sort by company ID"
  COMPANY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for company locations"
input CompanyLocationSortInput {
  "Field to sort by"
  field: CompanyLocationSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create company location input"
input CreateCompanyLocationInput {
  "Company location name"
  name: String!

  "Associated company ID"
  companyId: ID!
}

"Update company location data"
input UpdateCompanyLocationInput {
  "New company location name"
  name: String!
}

"Company location creation response"
type CreateCompanyLocationPayload {
  "Created company location"
  companyLocation: CompanyLocation

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Company location update response"
type UpdateCompanyLocationPayload {
  "Updated company location"
  companyLocation: CompanyLocation

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Company location deletion response"
type DeleteCompanyLocationPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted company location ID"
  deletedId: ID
}

"Response for can delete company location"
type CanDeleteCompanyLocationPayload {
  "Whether the company location can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for CompanyLocation"
type CompanyLocationChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a CompanyLocation"
type CompanyLocationTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CompanyLocationChange]!
}

"Filters for CompanyLocation timeline"
input CompanyLocationTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for CompanyLocation timeline"
enum CompanyLocationTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for CompanyLocation timeline"
input CompanyLocationTimelineSortInput {
  "Field to sort by"
  field: CompanyLocationTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for CompanyLocation timeline"
type CompanyLocationTimelinePage {
  "Timeline items for current page"
  entries: [CompanyLocationTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Storage status enum"
enum StorageStatus {
  "Storage is active and operational"
  ACTIVE

  "Storage is in read-only mode"
  READ_ONLY

  "Storage is inactive"
  INACTIVE
}

"Storage entity"
type Storage {
  "Unique storage identifier"
  id: ID

  "Storage name"
  name: String

  "Storage address"
  address: String

  "Storage status"
  status: StorageStatus

  "Associated company"
  company: Company

  "Associated company location"
  companyLocation: CompanyLocation

  "Associated city"
  city: City

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated storages response"
type StoragePage {
  "List of storages for current page"
  entries: [Storage]!

  "Total number of storages matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching storages"
input StorageFilters {
  "Filter by storage name (partial match)"
  name: String

  "Search in name and address"
  matching: String

  "Filter by storage status"
  status: StorageStatus

  "Filter by company ID"
  companyId: ID

  "Filter by company location ID"
  companyLocationId: ID

  "Filter by city ID"
  cityId: ID
}

"Available fields for sorting storages"
enum StorageSortField {
  "Sort by storage ID"
  ID

  "Sort by storage name"
  NAME

  "Sort by address"
  ADDRESS

  "Sort by status"
  STATUS

  "Sort by company location ID"
  COMPANY_LOCATION_ID

  "Sort by city ID"
  CITY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for storages"
input StorageSortInput {
  "Field to sort by"
  field: StorageSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create storage input"
input CreateStorageInput {
  "Storage name"
  name: String!

  "Storage address"
  address: String

  "Storage status"
  status: StorageStatus

  "Associated company location ID"
  companyLocationId: ID!

  "Associated city ID"
  cityId: ID!
}

"Update storage data"
input UpdateStorageInput {
  "Storage name"
  name: String

  "Storage address"
  address: String

  "Storage status"
  status: StorageStatus

  "Associated company location ID"
  companyLocationId: ID

  "Associated city ID"
  cityId: ID
}

"Storage creation response"
type CreateStoragePayload {
  "Created storage"
  storage: Storage

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Storage update response"
type UpdateStoragePayload {
  "Updated storage"
  storage: Storage

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Storage deletion response"
type DeleteStoragePayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted storage ID"
  deletedId: ID
}

"Response for can delete storage"
type CanDeleteStoragePayload {
  "Whether the storage can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Storage"
type StorageChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Storage"
type StorageTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [StorageChange]!
}

"Filters for Storage timeline"
input StorageTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Storage timeline"
enum StorageTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Storage timeline"
input StorageTimelineSortInput {
  "Field to sort by"
  field: StorageTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Storage timeline"
type StorageTimelinePage {
  "Timeline items for current page"
  entries: [StorageTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Company status enumeration"
enum CompanyStatus {
  "Company is active and operational"
  ACTIVE

  "Company is temporarily suspended"
  SUSPENDED

  "Company is archived and inactive"
  ARCHIVED
}

"Company entity"
type Company {
  "Unique company identifier"
  id: ID

  "Company reference code"
  reference: String

  "Current company status"
  status: CompanyStatus

  "The accounting entity that represents this company"
  companyEntity: AccountingEntity

  "Company locations associated with this company"
  companyLocations: [CompanyLocation]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated company response"
type CompanyPage {
  "List of companies for current page"
  entries: [Company]!

  "Total number of companies matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching companies"
input CompanyFilters {
  "Filter by company reference"
  reference: String

  "Filter by company status"
  status: CompanyStatus

  "Filter companies created after this date"
  insertedAfter: IsoDatetime

  "Filter companies created before this date"
  insertedBefore: IsoDatetime
}

"Available fields for sorting companies"
enum CompanySortField {
  "Sort by company ID"
  ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for companies"
input CompanySortInput {
  "Field to sort by"
  field: CompanySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create company input"
input CreateCompanyInput {
  "Company reference code"
  reference: String!

  "Company status (defaults to active)"
  status: CompanyStatus

  "Default currency ID"
  defaultCurrencyId: ID

  "Accounting entity data"
  accountingEntity: CreateAccountingEntityInput!
}

"Update company input"
input UpdateCompanyInput {
  "Company reference code"
  reference: String

  "Company status"
  status: CompanyStatus

  "Default currency ID"
  defaultCurrencyId: ID

  "Accounting entity data"
  accountingEntity: UpdateAccountingEntityInput
}

"Company mutation response"
type CompanyMutationPayload {
  "Company data"
  company: Company

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Response for company creation"
type CreateCompanyPayload {
  "Created company"
  company: Company

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Response for company updates"
type UpdateCompanyPayload {
  "Updated company"
  company: Company

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Response for company deletion"
type DeleteCompanyPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted company ID"
  deletedId: ID
}

"Response for can delete company"
type CanDeleteCompanyPayload {
  "Whether the company can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"City entity"
type City {
  "Unique city identifier"
  id: ID

  "Unique city code"
  code: String

  "City name"
  name: String

  "Department this city belongs to"
  department: Department

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated city response"
type CityPage {
  "List of cities for current page"
  entries: [City]!

  "Total number of cities matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching cities"
input CityFilters {
  "Filter by exact city code"
  code: String

  "Filter by city name (partial match)"
  name: String

  "Search in both code and name"
  matching: String

  "Filter by department ID"
  departmentId: ID
}

"Available fields for sorting cities"
enum CitySortField {
  "Sort by city ID"
  ID

  "Sort by city code"
  CODE

  "Sort by city name"
  NAME

  "Sort by department ID"
  DEPARTMENT_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for cities"
input CitySortInput {
  "Field to sort by"
  field: CitySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create city input"
input CreateCityInput {
  "Unique city code"
  code: String!

  "City name"
  name: String!

  "Department ID this city belongs to"
  departmentId: ID!
}

"Update city data"
input UpdateCityInput {
  "New city name"
  name: String!
}

"City creation response"
type CreateCityPayload {
  "Created city"
  city: City

  "Operation success status"
  success: Boolean

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"City update response"
type UpdateCityPayload {
  "Updated city"
  city: City

  "Operation success status"
  success: Boolean

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"City deletion response"
type DeleteCityPayload {
  "Operation success status"
  success: Boolean

  "Response message"
  message: String

  "Deleted city ID"
  deletedId: ID
}

"Response for can delete city"
type CanDeleteCityPayload {
  "Whether the city can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for City"
type CityChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a City"
type CityTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CityChange]!
}

"Filters for City timeline"
input CityTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for City timeline"
enum CityTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for City timeline"
input CityTimelineSortInput {
  "Field to sort by"
  field: CityTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for City timeline"
type CityTimelinePage {
  "Timeline items for current page"
  entries: [CityTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Department entity"
type Department {
  "Unique department identifier"
  id: ID

  "Unique department code"
  code: String

  "Department name"
  name: String

  "Country this department belongs to"
  country: Country

  "Cities in this department"
  cities: [City]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated department response"
type DepartmentPage {
  "List of departments for current page"
  entries: [Department]!

  "Total number of departments matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching departments"
input DepartmentFilters {
  "Filter by country ID"
  countryId: ID

  "Filter by department name (partial match)"
  name: String

  "Search in both code and name"
  matching: String
}

"Available fields for sorting departments"
enum DepartmentSortField {
  "Sort by department ID"
  ID

  "Sort by department code"
  CODE

  "Sort by department name"
  NAME

  "Sort by country ID"
  COUNTRY_ID

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for departments"
input DepartmentSortInput {
  "Field to sort by"
  field: DepartmentSortField!

  "Sort direction"
  direction: SortDirection!
}

"Create department input"
input CreateDepartmentInput {
  "Unique department code"
  code: String!

  "Department name"
  name: String!

  "Country ID this department belongs to"
  countryId: ID!
}

"Update department data"
input UpdateDepartmentInput {
  "New department name"
  name: String!
}

"Department creation response"
type CreateDepartmentPayload {
  "Created department"
  department: Department

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Department update response"
type UpdateDepartmentPayload {
  "Updated department"
  department: Department

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Department deletion response"
type DeleteDepartmentPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted department ID"
  deletedId: ID
}

"Response for can delete department"
type CanDeleteDepartmentPayload {
  "Whether the department can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Department"
type DepartmentChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Department"
type DepartmentTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [DepartmentChange]!
}

"Filters for Department timeline"
input DepartmentTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Department timeline"
enum DepartmentTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Department timeline"
input DepartmentTimelineSortInput {
  "Field to sort by"
  field: DepartmentTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Department timeline"
type DepartmentTimelinePage {
  "Timeline items for current page"
  entries: [DepartmentTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Account entity (global reference only; not used for authentication)"
type Account {
  "Mirrors the authentication system account ID"
  id: ID

  email: String

  firstName: String

  middleName: String

  firstLastName: String

  middleLastName: String

  "Computed full name (concatenation of name parts)"
  fullName: String

  profession: String

  photoUrl: String

  insertedAt: IsoDatetime

  updatedAt: IsoDatetime
}

"Country entity"
type Country {
  "Unique country identifier"
  id: ID

  "Unique country code"
  code: String

  "Country name"
  name: String

  "Departments in this country"
  departments: [Department]

  "User who created this record"
  createdBy: Account

  "Creation timestamp"
  insertedAt: IsoDatetime

  "Last update timestamp"
  updatedAt: IsoDatetime
}

"Paginated country response"
type CountryPage {
  "List of countries for current page"
  entries: [Country]!

  "Total number of countries matching filter"
  totalEntries: Int!

  "Number of items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total number of pages"
  totalPages: Int!
}

"Filters for searching countries"
input CountryFilters {
  "Filter by exact country code"
  code: String

  "Filter by country name (partial match)"
  name: String

  "Search in both code and name"
  matching: String
}

"Available fields for sorting countries"
enum CountrySortField {
  "Sort by country ID"
  ID

  "Sort by country code"
  CODE

  "Sort by country name"
  NAME

  "Sort by creation date"
  INSERTED_AT

  "Sort by last update date"
  UPDATED_AT
}

"Sort configuration for countries"
input CountrySortInput {
  "Field to sort by"
  field: CountrySortField!

  "Sort direction"
  direction: SortDirection!
}

"Create country input"
input CreateCountryInput {
  "Unique country code"
  code: String!

  "Country name"
  name: String!
}

"Update country data"
input UpdateCountryInput {
  "New country name"
  name: String!
}

"Country creation response"
type CreateCountryPayload {
  "Created country"
  country: Country

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Country update response"
type UpdateCountryPayload {
  "Updated country"
  country: Country

  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Validation errors"
  errors: [FieldError]
}

"Country deletion response"
type DeleteCountryPayload {
  "Operation success status"
  success: Boolean!

  "Response message"
  message: String

  "Deleted country ID"
  deletedId: ID
}

"Response for can delete country"
type CanDeleteCountryPayload {
  "Whether the country can be deleted"
  canDelete: Boolean!

  "Reason message if it cannot be deleted"
  message: String
}

"Humanized field-level change for Country"
type CountryChange {
  "Field name"
  field: String!

  "Change operation"
  op: AuditOp!

  "Previous value as string"
  old: String

  "New value as string"
  new: String
}

"Timeline item for a Country"
type CountryTimelineItem {
  "Audit version identifier"
  version: ID!

  "Audit action"
  action: AuditAction!

  "When the change was recorded"
  recordedAt: IsoDatetime!

  "User who performed the action"
  user: Account

  "Humanized field-level changes"
  changes: [CountryChange]!
}

"Filters for Country timeline"
input CountryTimelineFilters {
  "Filter by action type"
  action: AuditAction

  "From timestamp (inclusive)"
  from: IsoDatetime

  "To timestamp (inclusive)"
  to: IsoDatetime
}

"Sort fields for Country timeline"
enum CountryTimelineSortField {
  "Sort by recorded_at"
  RECORDED_AT

  "Sort by action"
  ACTION
}

"Sort configuration for Country timeline"
input CountryTimelineSortInput {
  "Field to sort by"
  field: CountryTimelineSortField!

  "Sort direction"
  direction: SortDirection!
}

"Paginated response for Country timeline"
type CountryTimelinePage {
  "Timeline items for current page"
  entries: [CountryTimelineItem]!

  "Total number of timeline items"
  totalEntries: Int!

  "Items per page"
  pageSize: Int!

  "Current page number"
  pageNumber: Int!

  "Total pages"
  totalPages: Int!
}

"Pagination input for list queries"
input Pagination {
  "Page number (1-based)"
  page: Int

  "Number of items per page"
  pageSize: Int
}

"Sort direction enum"
enum SortDirection {
  "Ascending order"
  ASC

  "Descending order"
  DESC
}

"Field-specific error information"
type FieldError {
  "Campos involucrados en el error (1..N)"
  fields: [String!]!

  "Mensaje de error"
  message: String!

  code: String
}

"ISO 4217 currency code"
scalar CurrencyCode

"ISO8601 Date (YYYY-MM-DD)"
scalar IsoDate

"ISO8601 DateTime with Colombia timezone offset (-05:00)"
scalar IsoDatetime

"""
The `Date` scalar type represents a date. The Date appears in a JSON
response as an ISO8601 formatted string, without a time component.
"""
scalar Date

"""
The `Time` scalar type represents a time. The Time appears in a JSON
response as an ISO8601 formatted string, without a date component.
"""
scalar Time

"""
The `Decimal` scalar type represents signed double-precision fractional
values parsed by the `Decimal` library. The Decimal appears in a JSON
response as a string to preserve precision.
"""
scalar Decimal
